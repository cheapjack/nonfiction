<!DOCTYPE HTML>
<html>

<!-- HEADER -->
<head>

<meta charset="UTF-8">

<title>Sugar Rush</title>

<script src="BitsyNav3.js"></script>
<script type="bitsyGameData" id="exportedGameData">
Sugar Rush

# BITSY VERSION 5.5

! ROOM_FORMAT 1

PAL 0
112,148,204
236,255,156
255,211,124

ROOM 0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,a,a,a,a,a,a,a,a,a,a,a,a,a,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,e,d,f,d,a,0
0,a,0,0,0,0,0,0,0,0,c,0,c,0,a,0
0,a,0,0,0,0,0,0,0,0,c,0,c,0,a,0
0,a,0,0,0,0,0,0,0,0,c,0,c,0,a,0
0,a,0,0,0,0,0,0,0,0,c,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,c,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,a,a,a,a,a,a,a,a,a,a,a,a,a,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ITM 0 10,3
ITM 2 13,8
EXT 15,3 3 0,3
PAL 0

ROOM 1
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,e5,e5,e5,e5,e5,e5,e5,e5,e5,e5,0,0,0
0,0,e5,19,6,6,1a,7,1b,8,1c,1d,1e,e5,0,0
0,e5,1f,9,1g,1h,h,7,1j,i,1k,j,k,2,e5,0
e5,e5,l,m,n,o,p,0,6,q,r,s,e3,t,e5,0
a,a,v,e3,1o,1p,w,e3,e3,e3,e3,e3,e3,e3,e5,e5
0,e3,e3,e3,2l,1w,e3,e3,e3,e3,2l,2l,e3,e3,e3,e3
e6,e6,e3,e3,e3,e3,e3,e3,e3,2l,25,26,2l,e3,e5,e5
0,e6,28,e3,2l,29,12,2l,e3,2p,13,2b,2q,14,e5,0
0,0,e6,2c,e3,2e,e6,15,2f,2g,e6,e6,e6,e5,0,0
0,0,0,e6,e6,e6,e6,e6,e6,e6,e6,e6,e6,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME Sugar 1
EXT 15,6 2 0,5
EXT 0,6 3 15,3
PAL 0

ROOM 2
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,2k,cw,3u,cx,cw,3u,0,0,0,0,0
0,0,0,cy,cz,d0,e3,d1,4r,e3,e3,d2,d3,0,0,0
0,0,d4,d5,e3,d6,e3,d7,d8,e3,d9,e3,e3,db,0,0
a,2k,dc,e3,e3,e3,e3,e3,e3,e3,e3,e3,2l,2l,dd,0
e3,e3,e3,e3,de,df,2l,e3,e3,e3,e3,e3,e3,e3,e3,a
a,dh,e3,e3,di,e3,2l,e3,e3,e3,e3,e3,e3,e3,e3,e3
0,dk,82,e3,dl,e3,e3,e3,e3,e3,e3,dn,e3,e3,do,a
0,0,dp,e3,e3,dq,dr,ds,e3,dt,du,dv,8n,dw,0,0
0,0,2t,dx,dy,dz,2t,e0,e1,e2,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME Sugar 2
EXT 15,6 4 0,3
EXT 0,5 2 15,3
PAL 0

ROOM 3
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,a,a,a,a,a,a,a,a,a,a,a,a,a,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,g,0,0,0,0,0,0,0,0,0,0,0,0,0,0
g,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,a,0,0,0,0,0,a,0,0,a,0
0,a,0,0,0,a,0,0,0,0,0,a,0,g,a,0
0,a,0,0,0,a,0,0,0,0,0,a,0,0,a,0
0,a,0,0,0,a,0,0,0,0,0,a,0,0,a,0
0,a,0,0,0,a,0,0,0,0,0,a,0,0,a,0
0,a,0,0,0,a,a,a,a,a,a,a,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,a,a,a,a,a,a,a,a,a,a,a,a,a,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
EXT 0,3 0 15,3
EXT 15,3 1 0,6
PAL 0

ROOM 4
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,a,a,a,a,a,a,a,a,a,a,a,a,a,a,0
a,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,g,0,0,0,0,0,0,0,0,0,0,0,0,0,0
a,a,0,0,0,0,0,0,0,0,0,0,e9,e9,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,g,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,1,1,1,e7,1,1,1,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,a,a,a,a,a,a,a,a,a,a,a,a,a,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
EXT 0,3 2 15,6
END 0 15,3
PAL 0

TIL 1
11111111
01111111
01111111
01111111
01111111
01111111
11111111
11111111
NAME tile
WAL true

TIL 2
10000000
11100000
11100000
00110000
00111000
11111110
11111111
11111111
NAME Sugar 2 2
WAL true

TIL 3
01000000
11100001
11110011
10010011
10011111
00011111
00000111
00100111
NAME Sugar 2 3
WAL true

TIL 4
11111000
11111000
11110000
11110000
11110000
11100000
11000000
11000000
NAME Sugar 2 4
WAL true

TIL 5
00000000
00000000
00000011
00001111
00111100
11100001
11100000
00100000
NAME Sugar 2 5
WAL true

TIL 6
00011111
01111111
11011111
01110111
01000111
00000111
00000111
10001111
NAME tile

TIL 7
00111100
00111111
00011111
00110001
00100000
00000000
01000000
11000000
NAME Sugar 2 7
WAL true

TIL 8
00000000
11100000
11011000
00111100
01101111
01111111
00111111
00111111
NAME Sugar 2 8
WAL true

TIL 9
00001111
00011111
00110100
01100000
11000000
00000000
01000000
00100000
NAME Sugar 2 9
WAL true

TIL 10
11110011
11110001
11111000
11111000
11111001
11111011
11111111
11111111
NAME Sugar 2 29
WAL true

TIL 11
00111111
11011101
11101101
11001111
11111111
11111111
10111111
11111111
NAME Sugar 2 30
WAL true

TIL 12
11111111
11111111
11111111
00111111
00001111
00000000
00000001
00000011
NAME Sugar 2 31
WAL true

TIL 13
10000000
11110000
11100000
10000000
00111000
11000000
11100000
00000000
NAME Sugar 2 32
WAL true

TIL 14
11111111
11111111
11111110
11111100
11110000
11000000
10000000
00000000
NAME Sugar 2 33
WAL true

TIL 15
11111111
01111111
00000011
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 34
WAL true

TIL 16
00000000
00000000
00000000
00000000
00000000
00000000
01100000
11000000
NAME Sugar 2 35
WAL true

TIL 17
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00111111
NAME Sugar 2 36
WAL true

TIL 18
00000000
00000000
00000000
00000000
00000000
00000000
00000001
10110000
NAME Sugar 2 37
WAL true

TIL 19
00000000
00000000
00000000
00000000
00000000
00000000
00000011
00000111
NAME Sugar 2 38
WAL true

TIL 20
11111000
11111000
11111100
11111000
11111000
11111000
11111000
11111000
NAME Sugar 2 65
WAL true

TIL 21
00000011
00000011
00000001
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 66
WAL true

TIL 22
11111100
11101111
11111111
11111111
11111111
11111111
11111111
11111110
NAME Sugar 2 67
WAL true

TIL 23
11111111
11111111
11111111
11111111
11111111
11111111
11111110
11111110
NAME Sugar 2 68
WAL true

TIL 24
11111111
11111111
11111111
11111111
11111111
00111111
00011111
00001111
NAME Sugar 2 69
WAL true

TIL 25
11111111
11111111
11111111
11111110
11111100
11111000
11110000
11100000
NAME Sugar 2 70
WAL true

TIL 26
00111111
01111111
00111111
00111111
00111111
00011111
00001111
00000111
NAME Sugar 2 71
WAL true

TIL 27
10111111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 72
WAL true

TIL 28
01111111
00111111
00111111
00011111
00001111
00001111
00000111
00000111
NAME Sugar 2 73
WAL true

TIL 29
11111111
11111111
11111110
11111110
11111110
11111100
11111100
11111100
NAME Sugar 2 74
WAL true

TIL 30
11111100
11111111
11111111
11110001
11100000
11000000
11000000
11000000
NAME Sugar 2 101
WAL true

TIL 31
11111111
11111111
11111111
11111111
11111111
01111111
01111111
00011111
NAME Sugar 2 102
WAL true

TIL 32
11111000
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 103
WAL true

TIL 33
00000000
00000000
10000000
11100000
11110000
11111100
11111110
11111111
NAME Sugar 2 104
WAL true

TIL 34
00000000
00000000
00000000
00000000
00000000
00000011
00000111
00001111
NAME Sugar 2 105
WAL true

TIL 35
00001111
00011111
00111111
01111111
11111111
11111111
11111111
11111111
NAME Sugar 2 106
WAL true

TIL 36
11111111
11111111
11111111
11111111
11111111
11111111
00011111
11111111
NAME Sugar 2 107
WAL true

TIL 37
11000000
11000000
11100000
11100111
11100111
11101111
11111111
11111111
NAME Sugar 2 108
WAL true

TIL 38
00011111
00011111
00111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 109
WAL true

TIL 39
11111111
11111111
11100011
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 110
WAL true

TIL 40
11111111
11111111
11111111
11111111
11111111
10011111
00011111
11111111
NAME Sugar 2 137
WAL true

TIL 41
11000000
11000000
11000000
11100111
11100111
11100111
11111111
11111111
NAME Sugar 2 138
WAL true

TIL 42
00001111
00011111
00111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 139
WAL true

TIL 43
11111111
11111111
11000001
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 140
WAL true

TIL 44
00000001
00000001
00000001
00000011
00000011
00000111
00000111
00000111
NAME Sugar 2 141
WAL true

TIL 45
11111111
11111111
11111111
11111111
11111111
11111011
11111011
11111111
NAME Sugar 2 142
WAL true

TIL 46
11110000
11111000
11111000
11110000
11111000
11110000
11111000
11111000
NAME Sugar 2 143
WAL true

TIL 47
00000111
00000111
00000111
00000111
00000111
00000111
00000011
00000011
NAME Sugar 2 144
WAL true

TIL 48
11111111
11111111
11110111
11111111
11111111
11111111
11101111
11111111
NAME Sugar 2 145
WAL true

TIL 49
11111000
11111000
11111000
11111000
11111000
11111000
11111000
11111000
NAME Sugar 2 146
WAL true

TIL 50
11111111
11111111
11111111
00111111
00011111
00001111
00000111
00000000
NAME Sugar 2 173
WAL true

TIL 51
11111110
11111100
11100000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 174
WAL true

TIL 52
00000000
00000000
00000011
00001111
00111111
01111111
11111111
11111111
NAME Sugar 2 175
WAL true

TIL 53
11111111
11111111
11111111
11111111
01111111
11111111
11111111
11111111
NAME Sugar 2 176
WAL true

TIL 54
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01111111
NAME Sugar 2 177
WAL true

TIL 55
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10000000
NAME Sugar 2 178
WAL true

TIL 56
00000000
00000000
00000001
00000011
00000111
01011111
01111111
11111111
NAME Sugar 2 179
WAL true

TIL 57
00000111
00011111
01111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 180
WAL true

TIL 58
11000000
11111111
11111000
11000000
11000000
10000000
10000000
10000000
NAME Sugar 2 181
WAL true

TIL 59
00011111
11111111
11111111
01111111
01001111
00001111
00011111
00001111
NAME Sugar 2 182
WAL true

TIL 60
00000111
00000111
00000111
00000011
00000011
00000011
00000011
00000001
NAME Sugar 2 209
WAL true

TIL 61
11111111
11111111
11111111
11111111
11111111
11111111
11111011
11111111
NAME Sugar 2 210
WAL true

TIL 62
11100011
11100011
11000011
11001111
11111111
11110011
11000111
11100010
NAME Sugar 2 211
WAL true

TIL 63
11111111
11111111
11111111
11111111
01111111
11111111
11100001
11101111
NAME Sugar 2 212
WAL true

TIL 64
11111111
11111111
11111111
11111111
10011101
11111110
11111110
11111111
NAME Sugar 2 213
WAL true

TIL 65
11111100
11111000
11111000
00111011
11111001
00101101
00110111
00111101
NAME Sugar 2 214
WAL true

TIL 66
01111111
01111111
01111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 215
WAL true

TIL 67
11110000
11110000
11111000
11111000
11111000
11110000
11110000
11110000
NAME Sugar 2 216
WAL true

TIL 68
00111111
01111111
01111111
01111111
01111111
01111111
01111111
01111111
NAME Sugar 2 217
WAL true

TIL 69
11111111
11111111
11111111
11110111
11111111
11111111
11111111
11111111
NAME Sugar 2 218
WAL true

TIL 70
11111111
11111111
11111111
11111111
11111111
01111111
01111111
00111111
NAME Sugar 2 245
WAL true

TIL 71
00000000
00000000
10000000
11100000
11111000
11111100
11111110
11111111
NAME Sugar 2 246
WAL true

TIL 72
00000000
00000000
00000000
00000000
00000001
00000111
00000111
00001111
NAME Sugar 2 247
WAL true

TIL 73
00001111
00111111
01111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 248
WAL true

TIL 74
11111111
11111111
11111111
11111111
11111111
11111111
10111111
11111111
NAME Sugar 2 249
WAL true

TIL 75
11000000
11000000
11100000
11100111
11100111
11111111
11111111
11111111
NAME Sugar 2 250
WAL true

TIL 76
10000000
11100000
11100000
11110000
11111100
11111110
11111111
11111111
NAME Sugar 2 251
WAL true

TIL 77
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000001
NAME Sugar 2 252
WAL true

TIL 78
00011111
00111111
00111111
01111111
11111111
11111111
11111111
11111111
NAME Sugar 2 253
WAL true

TIL 79
11111000
11111000
11111000
11111000
11111000
11111000
11111000
11111100
NAME Sugar 2 254
WAL true

TIL 80
11111111
11111111
10111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 281
WAL true

TIL 81
11111111
11111111
11111111
11111111
11111111
11110011
11110011
11111111
NAME Sugar 2 282
WAL true

TIL 82
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01111111
NAME Sugar 2 283
WAL true

TIL 83
11110111
11111111
11111111
11111111
11111101
11111111
11111111
11111111
NAME Sugar 2 284
WAL true

TIL 84
11111111
11111111
11111111
11111111
11111111
11111111
01111111
11111111
NAME Sugar 2 285
WAL true

TIL 85
11111111
11111111
11111111
11111110
11111000
11111001
11111001
11110111
NAME Sugar 2 286
WAL true

TIL 86
11111111
11111111
11111111
00011111
00011111
11111111
11111111
11111111
NAME Sugar 2 287
WAL true

TIL 87
11111111
11111111
11111111
11110111
11111111
11111101
11111101
11111110
NAME Sugar 2 288
WAL true

TIL 88
11110000
11110000
11110000
11110000
11110000
11000000
11000000
11001000
NAME Sugar 2 289
WAL true

TIL 89
11100011
11100011
11100011
11101111
11111111
11110011
11100111
11101011
NAME Sugar 2 290
WAL true

TIL 90
00000000
00000000
00001111
00000100
00000100
00000101
00000010
00000000
NAME Sugar 2 317
WAL true

TIL 91
00000000
00000000
00000000
00000000
00000100
00000000
00001000
00000000
NAME Sugar 2 318
WAL true

TIL 92
00000000
00000000
00000000
00000000
00000001
00100011
01100111
01111111
NAME Sugar 2 319
WAL true

TIL 93
00000000
00000000
00000000
00000000
11100000
11100000
10001100
00000000
NAME Sugar 2 320
WAL true

TIL 94
10010000
00000000
00000000
01000000
00000001
00000000
00000000
00000000
NAME Sugar 2 321
WAL true

TIL 95
00000000
00000000
00000000
00010000
00000000
00000000
00000000
00000001
NAME Sugar 2 322
WAL true

TIL 96
00000000
00000000
10000000
00000000
00000000
00001000
00001100
00000000
NAME Sugar 2 323
WAL true

TIL 97
00001000
00000000
00000000
00000000
01000000
00000000
00000000
00000000
NAME Sugar 2 324
WAL true

TIL 98
00000000
00000000
00000000
00000010
00000000
00001010
00011111
00011100
NAME Sugar 2 325
WAL true

TIL 99
00010000
00010000
10000000
00000000
00100000
11000000
10000000
01000000
NAME Sugar 2 326
WAL true

TIL a
11111111
10000001
10000001
10011001
10011001
10000001
10000001
11111111
WAL true

TIL b
00000001
00000010
00000100
00001000
00010000
00100000
01000000
10000000

TIL c
00011000
00011000
00011000
00011000
00011000
00011000
00011000
00011000
WAL true

TIL d
00000000
00000000
00000000
11111111
11111111
00000000
00000000
00000000
WAL true

TIL e
00000000
00000000
00000000
00011111
00011111
00011000
00011000
00011000
WAL true

TIL f
00000000
00000000
00000000
11111111
11111111
00011000
00011000
00011000
WAL true

TIL g
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL h
11000000
01100000
11000000
11001111
10011111
11111111
11111111
01011111
NAME Sugar 2 10
WAL true

TIL i
00111111
00011111
11010111
11011100
11001110
11000111
11000100
11101100
NAME Sugar 2 11
WAL true

TIL j
00000000
11110000
11111000
11111110
11111111
11111111
11111111
11001111
NAME Sugar 2 12
WAL true

TIL k
00001011
00000011
00000001
00110001
10001110
11101110
11100111
11110011
NAME Sugar 2 13
WAL true

TIL l
00011110
00011111
00111110
01111100
01111100
11110001
11101101
11101111
NAME Sugar 2 14
WAL true

TIL m
00010111
00000111
00011011
01111111
11111111
11111111
00111111
11111111
NAME Sugar 2 15
WAL true

TIL n
11111111
11111111
11111110
11111111
11111110
11111100
11111000
11110001
NAME Sugar 2 16
WAL true

TIL o
11111000
11111100
11111100
11011100
11011111
00011111
00011111
11111111
NAME Sugar 2 17
WAL true

TIL p
00001111
00000100
00000000
11000000
11100000
11000000
11100011
11111111
NAME Sugar 2 18
WAL true

TIL q
00111111
01110111
00110011
10000011
11000000
11100000
11100001
11111100
NAME Sugar 2 19
WAL true

TIL r
11001111
11100000
11111000
11111111
11111111
00111111
00011111
10001111
NAME Sugar 2 20
WAL true

TIL s
10000111
00010111
00001111
10000111
11110011
11111001
11111111
11111111
NAME Sugar 2 21
WAL true

TIL t
01111111
11110111
11111111
11111011
11111001
11110000
11111010
11111110
NAME Sugar 2 22
WAL true

TIL u
10000000
11000000
11100000
11100000
11100000
00110000
00110000
00110000
NAME Sugar 2 23
WAL true

TIL v
10111111
10001111
10001111
00011111
00001111
00001111
00001111
00001111
NAME Sugar 2 24
WAL true

TIL w
11001111
11000111
11000111
10000111
00001111
01111111
11101111
11001111
NAME Sugar 2 25
WAL true

TIL x
11111111
11111111
11111111
11111111
11000001
00000001
11000110
01001110
NAME Sugar 2 26
WAL true

TIL y
00110000
11111000
11111000
11111000
11111000
11111000
11111000
11111000
NAME Sugar 2 27
WAL true

TIL z
00000111
00000111
00000111
00000111
00000111
00000111
00000111
00000011
NAME Sugar 2 28
WAL true

TIL 1a
11100000
11110000
11110100
11110000
11100000
11000000
11100000
11100000
NAME Sugar 2 39
WAL true

TIL 1b
11000000
10000000
10000000
10000000
10000000
00000000
01000000
00010000
NAME Sugar 2 40
WAL true

TIL 1c
00000000
00000000
00000000
00000000
10000000
00010000
00000000
11100000
NAME Sugar 2 41
WAL true

TIL 1d
00111000
00001011
00000001
00000011
00000000
00000000
00000000
00000000
NAME Sugar 2 42
WAL true

TIL 1e
00000000
00000000
10000000
11100000
00010000
00011100
00000100
00000011
NAME Sugar 2 43
WAL true

TIL 1f
00000000
00000000
00000000
00000000
00000001
00000011
00000110
00001100
NAME Sugar 2 44
WAL true

TIL 1g
00000000
00000000
00000000
00000000
00000001
00000001
00001111
00111111
NAME Sugar 2 45
WAL true

TIL 1h
00011111
01011111
01111111
01111111
11111111
11111111
00011111
11111111
NAME Sugar 2 46
WAL true

TIL 1i
11000000
01000000
01000000
11100111
11100111
11101111
11111111
11111111
NAME Sugar 2 47
WAL true

TIL 1j
00011000
00011111
00111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 48
WAL true

TIL 1k
11111110
11111111
11111111
11111111
11111111
01001111
01001111
11001111
NAME Sugar 2 49
WAL true

TIL 1l
11110011
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 50
WAL true

TIL 1m
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00111111
NAME Sugar 2 51
WAL true

TIL 1n
00000001
00000001
00000001
00000011
00000100
00000110
00000100
00000100
NAME Sugar 2 52
WAL true

TIL 1o
11110111
11100111
11101111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 53
WAL true

TIL 1p
11111110
11111100
11111110
11111111
10111111
11111111
11111111
11111111
NAME Sugar 2 54
WAL true

TIL 1q
11111111
11111111
11111111
11111111
11111101
11000000
11000000
11010000
NAME Sugar 2 55
WAL true

TIL 1r
10001111
11111111
11111111
11111111
11111111
01111111
11111111
11111111
NAME Sugar 2 56
WAL true

TIL 1s
00111111
11111111
11011111
11101111
11111111
11111111
11110001
11110011
NAME Sugar 2 57
WAL true

TIL 1t
11111000
11111111
11111111
11111111
10111111
11111111
11111111
10111111
NAME Sugar 2 58
WAL true

TIL 1u
00000111
00011111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 59
WAL true

TIL 1v
11111111
11111001
11111011
11111011
11111111
11111111
11111111
11111111
NAME Sugar 2 60
WAL true

TIL 1w
11111111
11111111
11111111
11101111
11001111
11111111
11111111
11111111
NAME Sugar 2 61
WAL true

TIL 1x
11111110
11111111
11111011
11111011
11111101
11101000
11101011
10001111
NAME Sugar 2 62
WAL true

TIL 1y
01111100
11111100
11111100
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 63
WAL true

TIL 1z
00111111
00110111
00110110
11110011
11111111
11111111
11111111
11101111
NAME Sugar 2 64
WAL true

TIL 2a
00001111
00001111
10001111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 75
WAL true

TIL 2b
00000111
00000111
00000111
00000111
00000011
00000011
00000001
00000000
NAME Sugar 2 76
WAL true

TIL 2c
11111111
11111111
11111111
01111111
00011111
00001111
00000111
00000000
NAME Sugar 2 77
WAL true

TIL 2d
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00000100
NAME Sugar 2 78
WAL true

TIL 2e
11111000
11111000
11110000
11110000
11110000
11000000
00000000
00000000
NAME Sugar 2 79
WAL true

TIL 2f
11111111
11111111
00111111
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 80
WAL true

TIL 2g
11111110
11111100
11110000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 81
WAL true

TIL 2h
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000111
NAME Sugar 2 82
WAL true

TIL 2i
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01000000
NAME Sugar 2 83
WAL true

TIL 2j
00000000
00000000
00000000
00000000
00000000
00000000
10000000
00111100
NAME Sugar 2 84
WAL true

TIL 2k
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000001
NAME Sugar 2 85
WAL true

TIL 2l
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 86
WAL true

TIL 2m
11111110
11111111
11111111
11111111
11111111
11111111
01111111
00011111
NAME Sugar 2 87
WAL true

TIL 2n
11111101
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 88
WAL true

TIL 2o
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11011111
NAME Sugar 2 89
WAL true

TIL 2p
11111111
11111111
11111111
11111111
11111101
11111111
11111111
11111111
NAME Sugar 2 90
WAL true

TIL 2q
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10011110
NAME Sugar 2 91
WAL true

TIL 2r
10000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 92
WAL true

TIL 2s
00000011
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 93
WAL true

TIL 2t
00000001
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 94
WAL true

TIL 2u
00000000
00000000
00000000
00000000
00000000
00000000
01111111
11111111
NAME Sugar 2 95
WAL true

TIL 2v
00000000
00000000
00000000
00000000
00000000
00000000
10000000
11000000
NAME Sugar 2 96
WAL true

TIL 2w
00000000
00000000
00000000
00000000
00000000
00000000
00000011
11111111
NAME Sugar 2 97
WAL true

TIL 2x
00000000
00000000
00000000
00000000
00000000
00000000
10000000
11111100
NAME Sugar 2 98
WAL true

TIL 2y
00000000
00000000
00000011
00001111
00111111
11111111
11111111
11111111
NAME Sugar 2 99
WAL true

TIL 2z
00011111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 100
WAL true

TIL 3a
10000000
11100000
11100000
11110000
11111000
11111110
11111111
11111111
NAME Sugar 2 111
WAL true

TIL 3b
00011111
00011111
00111111
01111111
01111111
11111111
11111111
11111111
NAME Sugar 2 112
WAL true

TIL 3c
10000000
11000000
11100000
11100000
11100000
11110000
11110000
11110000
NAME Sugar 2 113
WAL true

TIL 3d
00000001
00000001
00000011
00000011
00000111
00000111
00000111
00000111
NAME Sugar 2 114
WAL true

TIL 3e
11111111
11111111
11111111
01111111
10111111
11111111
11111111
11111111
NAME Sugar 2 115
WAL true

TIL 3f
11110000
11111000
11111000
11111000
11111000
11111000
11111000
11111000
NAME Sugar 2 116
WAL true

TIL 3g
11111111
11111111
11111111
11111110
11111100
11111000
11110000
11000000
NAME Sugar 2 117
WAL true

TIL 3h
00111111
00111111
00111111
00111111
00111111
00011111
00000111
00000111
NAME Sugar 2 118
WAL true

TIL 3i
11111000
11110000
11110000
11110000
11110000
11100000
11000000
11000000
NAME Sugar 2 119
WAL true

TIL 3j
01111111
00111111
00111111
00011111
00001111
00001111
00000111
00000011
NAME Sugar 2 120
WAL true

TIL 3k
11111111
11111011
11111100
11111110
11111110
11111100
11111100
11111100
NAME Sugar 2 121
WAL true

TIL 3l
11111111
11111111
11111111
00111111
00001110
00000000
00000001
00000011
NAME Sugar 2 122
WAL true

TIL 3m
11111111
11111111
11111111
11111111
01111111
01111111
11111111
11111111
NAME Sugar 2 123
WAL true

TIL 3n
10000000
10110000
11100000
10000000
00000000
10000000
11000000
00000000
NAME Sugar 2 124
WAL true

TIL 3o
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10111110
NAME Sugar 2 125
WAL true

TIL 3p
11111111
11111111
11111110
11111100
11110000
11100000
10000000
00000000
NAME Sugar 2 126
WAL true

TIL 3q
00000011
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 127
WAL true

TIL 3r
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00001100
NAME Sugar 2 128
WAL true

TIL 3s
11111000
11111000
11111000
11110000
11110000
11000000
00000000
00000000
NAME Sugar 2 129
WAL true

TIL 3t
00000000
00000000
00000000
00000000
00000000
00000000
01100000
11111111
NAME Sugar 2 130
WAL true

TIL 3u
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11000000
NAME Sugar 2 131
WAL true

TIL 3v
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00011111
NAME Sugar 2 132
WAL true

TIL 3w
00000000
00000000
00000000
00000000
00000000
00000000
00000001
11111111
NAME Sugar 2 133
WAL true

TIL 3x
00000000
00000000
00000011
00001111
00011111
01111111
11111111
11111111
NAME Sugar 2 134
WAL true

TIL 3y
11111100
11111111
11111111
11100001
11100000
11000000
11000000
11000000
NAME Sugar 2 135
WAL true

TIL 3z
00000000
00000000
10000000
11100000
11110000
11111100
11111100
11111111
NAME Sugar 2 136
WAL true

TIL 4a
00000001
00000011
00000000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 147
WAL true

TIL 4b
00111111
00101111
00111111
00111111
00111111
00011111
00000111
00000111
NAME Sugar 2 148
WAL true

TIL 4c
11111000
11110000
11110000
11110000
11100000
11100000
11000000
11000000
NAME Sugar 2 149
WAL true

TIL 4d
11111111
11110011
11111100
11110110
11111100
11111100
11111100
11111100
NAME Sugar 2 150
WAL true

TIL 4e
11111111
11111111
11111111
00111111
00001100
00000000
00000001
00000011
NAME Sugar 2 151
WAL true

TIL 4f
11111111
11111111
11111111
11111111
00111111
01111111
11111111
11111111
NAME Sugar 2 152
WAL true

TIL 4g
11111111
11111111
11111111
11111111
11111100
11111110
11111111
11111111
NAME Sugar 2 153
WAL true

TIL 4h
10000000
10100000
10000000
10000000
00000000
00000000
10000000
00000000
NAME Sugar 2 154
WAL true

TIL 4i
00000111
00000111
00000111
00000011
00000011
00000011
00000001
00000000
NAME Sugar 2 155
WAL true

TIL 4j
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10011100
NAME Sugar 2 156
WAL true

TIL 4k
11111111
11111111
11111111
00111111
00011111
00001111
00000011
00000000
NAME Sugar 2 157
WAL true

TIL 4l
11111000
11111000
11110000
11110000
11100000
11000000
00000000
00000000
NAME Sugar 2 158
WAL true

TIL 4m
11111111
01111111
00000000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 159
WAL true

TIL 4n
11111111
10111111
00011111
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 160
WAL true

TIL 4o
11111100
11111100
11100000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 161
WAL true

TIL 4p
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000011
NAME Sugar 2 162
WAL true

TIL 4q
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00011110
NAME Sugar 2 163
WAL true

TIL 4r
11111111
11111111
11111111
11111111
01111111
01111111
00111111
00011111
NAME Sugar 2 164
WAL true

TIL 4s
10111000
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 165
WAL true

TIL 4t
00000000
00000000
10000000
11100000
11110000
11111100
11111100
11111110
NAME Sugar 2 166
WAL true

TIL 4u
00000000
00000000
00000000
00000000
00000001
00000011
00000111
00001111
NAME Sugar 2 167
WAL true

TIL 4v
11111111
11111111
11101111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 168
WAL true

TIL 4w
10000000
11000000
11100000
11110000
11111000
11111110
11111111
11111111
NAME Sugar 2 169
WAL true

TIL 4x
10000000
11000000
11000000
11100000
11100000
11110000
11110000
11110000
NAME Sugar 2 170
WAL true

TIL 4y
11111111
11111111
11111100
11111110
11111110
11111100
11111100
11111100
NAME Sugar 2 171
WAL true

TIL 4z
10000000
10110000
11100000
10000000
00001000
10000000
11000000
00000000
NAME Sugar 2 172
WAL true

TIL 5a
00000000
11111100
11111110
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 183
WAL true

TIL 5b
00000000
00000000
00000000
10000000
11000000
11110000
11111000
11111100
NAME Sugar 2 184
WAL true

TIL 5c
00000000
00000000
00000000
00000000
00000000
00000010
00000011
00000011
NAME Sugar 2 185
WAL true

TIL 5d
00000011
00001111
00001111
00011111
00111111
11111111
11111111
11111111
NAME Sugar 2 186
WAL true

TIL 5e
11111111
11111111
11111111
10111111
11001111
10001111
00000111
00111111
NAME Sugar 2 187
WAL true

TIL 5f
11000000
11000000
11000000
11000011
11100011
11100111
11101111
11111111
NAME Sugar 2 188
WAL true

TIL 5g
00000111
00001111
00001111
00111111
11111111
11111111
11111111
11111111
NAME Sugar 2 189
WAL true

TIL 5h
10111011
11000001
01000001
11100001
11000011
11111111
11111111
11111111
NAME Sugar 2 190
WAL true

TIL 5i
11111111
11111111
00111111
01111111
11111001
11111100
11111111
11111111
NAME Sugar 2 191
WAL true

TIL 5j
11111111
11111111
11111111
11111111
11111111
01111111
01111111
00101111
NAME Sugar 2 192
WAL true

TIL 5k
00000000
10000000
11000000
11000000
11110000
11111100
11111110
11111110
NAME Sugar 2 193
WAL true

TIL 5l
00001111
00011111
00001111
00111111
01111111
00111111
01111111
01111111
NAME Sugar 2 194
WAL true

TIL 5m
10111111
11111111
10111111
01111111
11111111
11111111
11111111
11111111
NAME Sugar 2 195
WAL true

TIL 5n
11111111
11111111
11111111
11111111
11111111
11110011
11110011
11111011
NAME Sugar 2 196
WAL true

TIL 5o
11110111
11111111
11111111
11111111
11111100
11111111
11111111
11111111
NAME Sugar 2 197
WAL true

TIL 5p
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10111111
NAME Sugar 2 198
WAL true

TIL 5q
00000000
10000000
11000000
11000000
11000000
11100000
11100000
11100000
NAME Sugar 2 199
WAL true

TIL 5r
00000001
00000000
00000001
00000001
00000011
00000011
00000011
00000011
NAME Sugar 2 200
WAL true

TIL 5s
11111111
11111111
10111111
11111111
11111111
01111111
01111111
01111111
NAME Sugar 2 201
WAL true

TIL 5t
11111111
11111111
11111111
11111110
11111000
11111001
11111001
11110101
NAME Sugar 2 202
WAL true

TIL 5u
11111111
11111111
10011111
00011111
00011111
10111111
11111111
11111111
NAME Sugar 2 203
WAL true

TIL 5v
11111111
11101111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 204
WAL true

TIL 5w
11111111
11111111
11111111
11111111
11111111
10111111
11111111
11111110
NAME Sugar 2 205
WAL true

TIL 5x
11111111
11111111
11111111
11110111
11111111
11111101
11111100
11111110
NAME Sugar 2 206
WAL true

TIL 5y
11111111
11111110
11111111
10111111
11111111
11111101
01111111
01111111
NAME Sugar 2 207
WAL true

TIL 5z
11100000
11110000
11110000
11110000
11110000
11000000
11000000
11001000
NAME Sugar 2 208
WAL true

TIL 6a
10111110
11111111
11111011
11111001
11111001
11111101
11111111
11111111
NAME Sugar 2 219
WAL true

TIL 6b
11111111
11111111
11111111
11111111
10111111
11111111
11111111
11011001
NAME Sugar 2 220
WAL true

TIL 6c
11111111
11111110
01111110
11111100
11110000
11110000
11100000
10000000
NAME Sugar 2 221
WAL true

TIL 6d
00011001
00000111
00001111
00111111
00001111
00001111
00000011
00000011
NAME Sugar 2 222
WAL true

TIL 6e
11110000
11110000
11100000
11100000
11100000
11000000
11000000
10000000
NAME Sugar 2 223
WAL true

TIL 6f
01111111
00011111
00011111
00011111
00000111
00000111
00000011
00000011
NAME Sugar 2 224
WAL true

TIL 6g
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111011
NAME Sugar 2 225
WAL true

TIL 6h
10010011
11100000
11100000
11100000
11111100
11111000
11111000
11111000
NAME Sugar 2 226
WAL true

TIL 6i
11111111
11111111
01111111
00010010
00000000
00000000
00000000
00000001
NAME Sugar 2 227
WAL true

TIL 6j
11111111
11111111
11111111
00000011
00001101
01111111
01111111
11111101
NAME Sugar 2 228
WAL true

TIL 6k
11111111
11111111
11111111
10011011
10111111
11111111
11111111
10011111
NAME Sugar 2 229
WAL true

TIL 6l
11111111
11111111
11111111
11111101
11111000
11111000
11111111
11101110
NAME Sugar 2 230
WAL true

TIL 6m
00000000
10000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 231
WAL true

TIL 6n
00000111
00000011
00000011
00000011
00000011
00000001
00000001
00000000
NAME Sugar 2 232
WAL true

TIL 6o
11111111
11111111
11111111
11111111
11111111
11011111
11111111
00000000
NAME Sugar 2 233
WAL true

TIL 6p
11011110
11111110
11111100
11111000
11100000
11000000
00000000
00000000
NAME Sugar 2 234
WAL true

TIL 6q
11111111
11111110
01111111
00111111
00011111
00000011
00000010
00000000
NAME Sugar 2 235
WAL true

TIL 6r
11111111
01111111
01111111
11111111
11111111
11111111
00001110
00000000
NAME Sugar 2 236
WAL true

TIL 6s
11110000
11110000
11100000
11100000
01000000
10000000
00000000
00000000
NAME Sugar 2 237
WAL true

TIL 6t
11111111
00000111
00000000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 238
WAL true

TIL 6u
10000111
10001111
00000111
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 239
WAL true

TIL 6v
11111100
11111000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 240
WAL true

TIL 6w
00000000
00000000
00000000
00000000
00000000
00000000
10000000
11100000
NAME Sugar 2 241
WAL true

TIL 6x
00000000
00000000
00000000
00000000
00000000
00000000
00010011
11111111
NAME Sugar 2 242
WAL true

TIL 6y
00000000
00000000
00000011
00011111
00111111
11111111
11111111
11111111
NAME Sugar 2 243
WAL true

TIL 6z
11111111
11111111
11111111
11110001
11100000
11000000
11000000
11000000
NAME Sugar 2 244
WAL true

TIL 7a
11111000
11111100
11111100
11111100
11111000
11111000
11111000
11111000
NAME Sugar 2 255
WAL true

TIL 7b
00000011
00000011
00000001
00000001
00000000
00000000
00000000
00000000
NAME Sugar 2 256
WAL true

TIL 7c
11111111
11111111
11111111
11111111
11111110
11111100
11111000
11100000
NAME Sugar 2 257
WAL true

TIL 7d
11111111
11111111
11111111
01111111
00111111
00111111
00011111
00000111
NAME Sugar 2 258
WAL true

TIL 7e
11111000
11111000
11110000
11110000
11110000
11100000
11100000
11100000
NAME Sugar 2 259
WAL true

TIL 7f
11111111
01111111
00111111
00111111
00001111
00001111
00000111
00000111
NAME Sugar 2 260
WAL true

TIL 7g
11111111
11111111
11111111
01111111
00001111
00000110
00000011
00000011
NAME Sugar 2 261
WAL true

TIL 7h
11110000
11110000
11100000
11111110
10111100
11110100
11100000
10000000
NAME Sugar 2 262
WAL true

TIL 7i
00000111
00000111
00000111
00000111
00000111
00000011
00000011
00000000
NAME Sugar 2 263
WAL true

TIL 7j
11111111
11111111
11111110
11111100
11111000
11100000
11000000
00000000
NAME Sugar 2 264
WAL true

TIL 7k
11000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 265
WAL true

TIL 7l
11111111
11111111
11111111
01111111
00111111
00001111
00000111
00000000
NAME Sugar 2 266
WAL true

TIL 7m
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00001110
NAME Sugar 2 267
WAL true

TIL 7n
11111111
01111111
00000111
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 268
WAL true

TIL 7o
11111111
11111111
11111111
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 269
WAL true

TIL 7p
00000000
00000000
00000001
00000011
00001111
01011111
01111111
11111111
NAME Sugar 2 270
WAL true

TIL 7q
00011111
11111111
11111111
01111111
01011111
00011111
00011111
00001111
NAME Sugar 2 271
WAL true

TIL 7r
00000000
00000000
00000000
10000000
11100000
11110000
11111000
11111100
NAME Sugar 2 272
WAL true

TIL 7s
00000000
00000000
00000000
00000000
00000000
00000011
00000011
00000111
NAME Sugar 2 273
WAL true

TIL 7t
00000011
00001111
00001111
00011111
01111111
11111111
11111111
11111111
NAME Sugar 2 274
WAL true

TIL 7u
11111111
11111111
11111111
11111111
11001111
10001111
00000111
00111111
NAME Sugar 2 275
WAL true

TIL 7v
11000000
11000000
11000000
11000011
11100111
11100111
11101111
11111111
NAME Sugar 2 276
WAL true

TIL 7w
11111111
11000001
11000001
11100001
11100011
11111111
11111111
11111111
NAME Sugar 2 277
WAL true

TIL 7x
11111111
11111111
11111111
11111111
11111111
11111111
01111111
00111111
NAME Sugar 2 278
WAL true

TIL 7y
00000000
10000000
11000000
11100000
11110000
11111100
11111110
11111110
NAME Sugar 2 279
WAL true

TIL 7z
00001111
00011111
00001111
01111111
01111111
00111111
01111111
11111111
NAME Sugar 2 280
WAL true

TIL 8a
11111111
11111111
11111111
11111111
11111111
11111111
11100001
11101111
NAME Sugar 2 291
WAL true

TIL 8b
11111111
11111111
11111111
11111111
10011111
11111111
11111111
11111111
NAME Sugar 2 292
WAL true

TIL 8c
11111100
11111000
11111010
00111111
11111101
01101101
00111111
00111101
NAME Sugar 2 293
WAL true

TIL 8d
01111111
11111111
01111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 294
WAL true

TIL 8e
00111111
01111111
11111111
01111111
01111111
11111111
01111111
01111111
NAME Sugar 2 295
WAL true

TIL 8f
11111110
11111111
11111111
11111001
11111101
11111101
11111111
11111111
NAME Sugar 2 296
WAL true

TIL 8g
11111111
11111111
11111111
11111111
10111111
11111111
11111111
11111001
NAME Sugar 2 297
WAL true

TIL 8h
11111111
11111110
01111110
11111100
11111000
11110000
11100000
10000000
NAME Sugar 2 298
WAL true

TIL 8i
10111011
11100000
11100000
11100000
11111100
11111000
11111000
11111000
NAME Sugar 2 299
WAL true

TIL 8j
11111111
11111111
11111111
00001011
00001111
01111111
11111111
11111101
NAME Sugar 2 300
WAL true

TIL 8k
11111111
11111111
11111111
10011111
11111111
11111111
11111111
10011111
NAME Sugar 2 301
WAL true

TIL 8l
11111111
11111111
11111111
11111101
11111000
11111100
11111111
11111110
NAME Sugar 2 302
WAL true

TIL 8m
10000000
10000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 303
WAL true

TIL 8n
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00000000
NAME Sugar 2 304
WAL true

TIL 8o
11111111
11111110
11111100
11111000
11100000
11000000
10000000
00000000
NAME Sugar 2 305
WAL true

TIL 8p
11111111
11111110
01111111
00111111
00011111
00000111
00000010
00000000
NAME Sugar 2 306
WAL true

TIL 8q
11111111
01111111
11111111
11111111
11111111
11111111
00001110
00000000
NAME Sugar 2 307
WAL true

TIL 8r
11110000
11110000
11100000
11110000
01000000
10000000
00000000
00000000
NAME Sugar 2 308
WAL true

TIL 8s
11111111
00011111
00000000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 309
WAL true

TIL 8t
10000111
10011111
00001111
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 310
WAL true

TIL 8u
00000000
00000000
00000000
00000001
00000000
00000000
00000000
00000000
NAME Sugar 2 311
WAL true

TIL 8v
00000001
00000001
00000000
00000000
00000000
00000001
00000000
00000001
NAME Sugar 2 312
WAL true

TIL 8w
00000000
10000000
01000000
00000000
00000000
00000000
00000000
10000000
NAME Sugar 2 313
WAL true

TIL 8x
00000000
00001100
00000000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 314
WAL true

TIL 8y
00000000
00001000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 315
WAL true

TIL 8z
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000100
NAME Sugar 2 316
WAL true

TIL 9a
11100000
10000000
00000000
00000000
00000000
00000010
00000000
00000000
NAME Sugar 2 327
WAL true

TIL 9b
00001000
00010001
00011100
00110110
00100111
00011111
00011111
00011110
NAME Sugar 2 328
WAL true

TIL 9c
00000000
00000000
00001000
11111100
01111100
01110000
01111100
11001111
NAME Sugar 2 329
WAL true

TIL 9d
00000000
00000000
00000000
00000001
00000000
00000000
00000000
10000000
NAME Sugar 2 330
WAL true

TIL 9e
00000000
00000000
00000000
00001000
00000110
00000111
00000010
00000011
NAME Sugar 2 331
WAL true

TIL 9f
00000001
00000000
00000000
00000000
00000000
01000000
00000000
00001000
NAME Sugar 2 332
WAL true

TIL 9g
00100000
00000001
00000000
01001100
01001100
00010000
00100001
00011101
NAME Sugar 2 333
WAL true

TIL 9h
00000000
00100000
00000001
00000000
10000000
00000000
10000000
00110000
NAME Sugar 2 334
WAL true

TIL 9i
00000000
00000000
00000000
00000000
00000000
00000010
00000000
00000010
NAME Sugar 2 335
WAL true

TIL 9j
01011000
10011001
10010011
11111100
11001110
00001110
00011000
00010010
NAME Sugar 2 336
WAL true

TIL 9k
11000000
10000000
00000110
00000100
00010000
00110000
00110000
01100000
NAME Sugar 2 337
WAL true

TIL 9l
01111100
11110000
00000000
00001000
00001000
10001000
11111100
10001110
NAME Sugar 2 338
WAL true

TIL 9m
00011110
00011111
11011111
10000100
10000000
00000000
00000000
00000000
NAME Sugar 2 339
WAL true

TIL 9n
11000111
11000111
00001001
00000000
00000000
00000000
10000000
00000000
NAME Sugar 2 340
WAL true

TIL 9o
11100000
11110000
11110000
00000000
00010000
00001000
00000000
00000000
NAME Sugar 2 341
WAL true

TIL 9p
00000001
00000101
00000000
00110011
00010001
00010000
00011100
00011110
NAME Sugar 2 342
WAL true

TIL 9q
00000110
10000011
11100011
10000001
10010001
11101100
01001100
11111100
NAME Sugar 2 343
WAL true

TIL 9r
00000000
00000000
00000001
00000000
11100000
11100000
01100000
00000000
NAME Sugar 2 344
WAL true

TIL 9s
00010000
11011000
11000010
00000111
00010011
00001001
00001100
00001101
NAME Sugar 2 345
WAL true

TIL 9t
00000000
00100000
01100000
00110000
01100000
00000000
00000000
00000000
NAME Sugar 2 346
WAL true

TIL 9u
00000000
00000000
00000000
00000001
00000001
00000001
00000011
00000001
NAME Sugar 2 347
WAL true

TIL 9v
00000011
00000001
00000100
10001101
11001111
10000001
10000001
10000111
NAME Sugar 2 348
WAL true

TIL 9w
11110000
00110000
00000000
11110000
11010000
11100001
11110001
10010000
NAME Sugar 2 349
WAL true

TIL 9x
01100000
00000000
10000001
11000001
01101111
10000001
11000000
00000000
NAME Sugar 2 350
WAL true

TIL 9y
10001111
01101111
00000111
00000110
00000010
10000000
00000000
00000100
NAME Sugar 2 351
WAL true

TIL 9z
10000000
10000000
10000000
00000000
01000000
11000000
10000000
00000000
NAME Sugar 2 352
WAL true

TIL a0
00000000
00000000
00000000
00000000
00000001
00000001
00000001
00000001
NAME Sugar 2 353
WAL true

TIL a1
00000000
00000000
00100000
11000000
11110000
11110000
10110000
00011000
NAME Sugar 2 354
WAL true

TIL a2
00111101
00111010
00011000
00000000
00000000
00000000
00000000
10100000
NAME Sugar 2 355
WAL true

TIL a3
10010000
10011000
01000000
00000000
00010000
00000000
00000000
00010000
NAME Sugar 2 356
WAL true

TIL a4
00100000
00100000
00100000
00010000
10100000
11100000
01000000
00000000
NAME Sugar 2 357
WAL true

TIL a5
00001100
00000000
00000000
00000000
00000100
00000001
00001110
00000110
NAME Sugar 2 358
WAL true

TIL a6
00000000
00000000
00000000
00000000
00000000
10000000
10000000
00000000
NAME Sugar 2 359
WAL true

TIL a7
00100000
00100001
01110001
00110011
00000011
00000000
00000000
01000000
NAME Sugar 2 360
WAL true

TIL a8
10000000
10001000
10000000
10000000
11000000
10000010
11000100
11000100
NAME Sugar 2 361
WAL true

TIL a9
00011000
00011110
00001001
00010001
00111001
00111001
00000000
00000111
NAME Sugar 2 362
WAL true

TIL aa
01111110
11111110
11101101
00000100
00110110
00010011
00010000
10000000
NAME Sugar 2 363
WAL true

TIL ab
00000000
00000000
00001000
00000000
00001100
00111111
00011000
11101000
NAME Sugar 2 364
WAL true

TIL ac
00000000
00000011
00111111
10011100
10011000
10011000
01110000
01110000
NAME Sugar 2 365
WAL true

TIL ad
00001000
00101100
00000111
00000011
00000001
00000001
00000001
00000001
NAME Sugar 2 366
WAL true

TIL ae
00000000
11101000
10100000
11000000
11000000
11110000
11111000
10001101
NAME Sugar 2 367
WAL true

TIL af
10101110
00001110
00111110
01110100
01110000
01110000
00000000
00000000
NAME Sugar 2 368
WAL true

TIL ag
00000000
00000000
00000011
00000011
00000110
00000000
00000000
00000000
NAME Sugar 2 369
WAL true

TIL ah
00110000
10000000
10100100
00100000
00000000
00000001
11000001
01000011
NAME Sugar 2 370
WAL true

TIL ai
00001110
00111100
00111001
01011100
01001111
01101101
01001011
11011110
NAME Sugar 2 371
WAL true

TIL aj
00000000
01100000
00100000
00100000
00100000
00000000
00000000
00000000
NAME Sugar 2 372
WAL true

TIL ak
00010001
00000001
00011001
00000000
00000100
00000110
00000010
00000001
NAME Sugar 2 373
WAL true

TIL al
11000000
11110000
11111000
11111000
11111110
01111110
10011011
11011010
NAME Sugar 2 374
WAL true

TIL am
00000011
00000000
00000000
00000000
00000000
00011011
01110010
01101100
NAME Sugar 2 375
WAL true

TIL an
10000001
00000000
01000000
01100000
00100000
11111000
11011000
00001000
NAME Sugar 2 376
WAL true

TIL ao
11001010
00000111
00110000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 377
WAL true

TIL ap
11111100
11011010
11010011
00000001
00000000
00000000
00111000
00011000
NAME Sugar 2 378
WAL true

TIL aq
00000010
00000100
00000010
00001000
00011000
11011000
10011111
00000000
NAME Sugar 2 379
WAL true

TIL ar
11111111
01111111
01011100
00011100
10111000
10100000
00100000
00001100
NAME Sugar 2 380
WAL true

TIL as
00000001
00000011
00000011
00000011
00000011
00000001
00000000
00000000
NAME Sugar 2 381
WAL true

TIL at
10011111
11111000
10001000
11111110
11111110
00001111
00001100
00000000
NAME Sugar 2 382
WAL true

TIL au
10000010
00000010
00000000
00000000
01000000
00000000
00000000
00000000
NAME Sugar 2 383
WAL true

TIL av
11011000
00011000
00011110
00011010
00001011
00000000
00000000
00000000
NAME Sugar 2 384
WAL true

TIL aw
00100000
00100000
00111100
00101100
10001100
00001110
00001100
00000000
NAME Sugar 2 385
WAL true

TIL ax
01111000
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 386
WAL true

TIL ay
00000001
00000010
00000010
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 387
WAL true

TIL az
11011000
00110000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 388
WAL true

TIL b0
00000000
00000000
00000000
00000000
00000000
00000000
00000011
00011111
NAME Sugar 2 389
WAL true

TIL b1
00000000
00000000
00000000
00000000
00000000
01000000
11111111
11111111
NAME Sugar 2 390
WAL true

TIL b2
00000000
00000000
00000000
00000000
00000000
00000000
11000000
11101100
NAME Sugar 2 391
WAL true

TIL b3
00000000
00000000
00000000
00000000
00000000
00000000
00011111
11111111
NAME Sugar 2 392
WAL true

TIL b4
00000000
00000000
00000000
00000000
00000000
00000000
11111111
11111111
NAME Sugar 2 393
WAL true

TIL b5
00000000
00000000
00000000
00000000
00000000
10000000
11111100
11111111
NAME Sugar 2 394
WAL true

TIL b6
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11110000
NAME Sugar 2 395
WAL true

TIL b7
00000000
00000000
00000000
00000000
00000000
00000001
00001111
00001111
NAME Sugar 2 396
WAL true

TIL b8
00000000
00000011
00001111
00111111
11111111
11111111
11111111
11111111
NAME Sugar 2 397
WAL true

TIL b9
11111111
11111111
11111111
11111111
11100001
11100000
11000000
11000000
NAME Sugar 2 398
WAL true

TIL ba
11111110
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 399
WAL true

TIL bb
00000000
00000000
11000000
11110000
11111100
11111110
11111110
11111111
NAME Sugar 2 400
WAL true

TIL bc
00000000
00000000
00000000
00000000
00000000
01000000
01000000
10000000
NAME Sugar 2 401
WAL true

TIL bd
00000000
00000000
00000000
00000001
00000011
00000111
00001111
00011111
NAME Sugar 2 402
WAL true

TIL be
00111111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 403
WAL true

TIL bf
11100000
11100000
11100011
11100111
11111111
11111111
11111111
11111111
NAME Sugar 2 404
WAL true

TIL bg
00011111
00111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 405
WAL true

TIL bh
10000000
11110000
11110000
11111000
11111110
11111110
11111111
11111111
NAME Sugar 2 406
WAL true

TIL bi
00000000
00000000
00000000
00000000
00000001
00000001
00000001
00000011
NAME Sugar 2 407
WAL true

TIL bj
11000000
11100000
11100000
11110000
11110000
11111000
11111000
11111000
NAME Sugar 2 408
WAL true

TIL bk
00000011
00000011
00000011
00000111
00000111
00000111
00000111
00001111
NAME Sugar 2 409
WAL true

TIL bl
11111100
11111100
11111000
11111100
11111100
11111100
11111100
11111100
NAME Sugar 2 410
WAL true

TIL bm
00001111
00001111
00001111
00001111
00001111
00001111
00001111
00000111
NAME Sugar 2 411
WAL true

TIL bn
11111100
11111100
11111100
11111100
11111100
11111100
11111100
11111100
NAME Sugar 2 412
WAL true

TIL bo
00000111
00000111
00000011
00000001
00000001
00000001
00000001
00000000
NAME Sugar 2 413
WAL true

TIL bp
11111111
11111111
11111111
11111111
11111110
11111100
11111000
11110000
NAME Sugar 2 414
WAL true

TIL bq
11111111
11111111
11111111
11111111
01111111
00111111
00011111
00001111
NAME Sugar 2 415
WAL true

TIL br
11111100
11111000
11111000
11110000
11110000
11110000
11100000
11100000
NAME Sugar 2 416
WAL true

TIL bs
11111111
11111111
01111111
01111111
00111111
00011111
00011111
00001111
NAME Sugar 2 417
WAL true

TIL bt
11111111
11111111
11111111
11111111
11111111
11111111
11111110
11111100
NAME Sugar 2 418
WAL true

TIL bu
11111111
11111111
11111111
11111111
00011111
00001111
00001111
00000111
NAME Sugar 2 419
WAL true

TIL bv
11111000
11111100
11111110
11111111
11111111
11111111
11111111
11110000
NAME Sugar 2 420
WAL true

TIL bw
00001111
00000111
00000111
00001111
11111111
11111111
11000011
00000001
NAME Sugar 2 421
WAL true

TIL bx
11111111
11111111
11111111
11111110
11111100
11110000
11000000
10000000
NAME Sugar 2 422
WAL true

TIL by
11100000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 423
WAL true

TIL bz
00000111
00000011
00000001
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 424
WAL true

TIL c0
11111111
11111111
11111111
11111111
01111111
00111111
00001111
00000111
NAME Sugar 2 425
WAL true

TIL c1
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00011111
NAME Sugar 2 426
WAL true

TIL c2
11111100
11111000
11111000
11111000
11111000
11000000
11000000
00000000
NAME Sugar 2 427
WAL true

TIL c3
11111111
11111111
00011111
00000001
00000000
00000000
00000000
00000000
NAME Sugar 2 428
WAL true

TIL c4
11111111
11111111
11111111
10001111
00000000
00000000
00000000
00000000
NAME Sugar 2 429
WAL true

TIL c5
11111111
11111110
11111000
00100000
00000000
00000000
00000000
00000000
NAME Sugar 2 430
WAL true

TIL c6
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00001111
NAME Sugar 2 431
WAL true

TIL c7
00000000
00000000
00000000
00000000
00000000
00000000
00001000
01111111
NAME Sugar 2 432
WAL true

TIL c8
00000000
00000000
00000000
00000000
00000000
00000000
11000000
11111111
NAME Sugar 2 433
WAL true

TIL c9
00000000
00000000
00000000
00000000
00000000
00000000
00000011
00001111
NAME Sugar 2 434
WAL true

TIL ca
00000000
00000000
00000111
00011111
00111111
11111111
11111111
11111111
NAME Sugar 2 435
WAL true

TIL cb
00011111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 436
WAL true

TIL cc
11111111
11111111
11111111
11111001
11100000
11000000
11000000
11000000
NAME Sugar 2 437
WAL true

TIL cd
11111100
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 438
WAL true

TIL ce
11000000
11100000
11100000
11100111
11101111
11111111
11111111
11111111
NAME Sugar 2 439
WAL true

TIL cf
00011111
00011111
01111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 440
WAL true

TIL cg
00000000
00000000
00000000
00000000
00000000
00000001
00000001
00000001
NAME Sugar 2 441
WAL true

TIL ch
00011111
00111111
01111111
01111111
11111111
11111111
11111111
11111111
NAME Sugar 2 442
WAL true

TIL ci
10000000
11000000
11100000
11100000
11110000
11110000
11110000
11111000
NAME Sugar 2 443
WAL true

TIL cj
00000001
00000001
00000011
00000111
00000111
00000111
00000111
00000111
NAME Sugar 2 444
WAL true

TIL ck
00000111
00000111
00001111
00000111
00000111
00000111
00000111
00000011
NAME Sugar 2 445
WAL true

TIL cl
11111100
11111100
11111100
11111100
11111000
11111000
11111000
11111000
NAME Sugar 2 446
WAL true

TIL cm
00000011
00000011
00000011
00000001
00000000
00000001
00000000
00000000
NAME Sugar 2 447
WAL true

TIL cn
11111111
11111111
11111111
01111111
00111111
00111111
00011111
00001111
NAME Sugar 2 448
WAL true

TIL co
11111111
01111111
01111111
00111111
00011111
00001111
00000111
00000111
NAME Sugar 2 449
WAL true

TIL cp
11111111
11111111
11111111
11111111
11111110
11111100
11111100
11111100
NAME Sugar 2 450
WAL true

TIL cq
11111111
11111111
11111111
01111111
00011111
00000111
00000011
00000011
NAME Sugar 2 451
WAL true

TIL cr
11110000
11111000
11110010
11111110
11111100
11111100
11100000
10000000
NAME Sugar 2 452
WAL true

TIL cs
00000111
00000111
00000111
00000111
00000111
00000011
00000011
00000001
NAME Sugar 2 453
WAL true

TIL ct
11111111
11111111
11111111
01111111
00111111
00011111
00000111
00000000
NAME Sugar 2 454
WAL true

TIL cu
11111000
11111000
11111000
11111000
11110000
11000000
10000000
00000000
NAME Sugar 2 455
WAL true

TIL cv
11111111
11111111
00000111
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 456
WAL true

TIL cw
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111111
NAME Sugar 2 457
WAL true

TIL cx
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00001000
NAME Sugar 2 458
WAL true

TIL cy
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000011
NAME Sugar 2 459
WAL true

TIL cz
00000000
00000000
00000001
00000111
00011111
01111111
11111111
11111111
NAME Sugar 2 460
WAL true

TIL d0
00001111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 461
WAL true

TIL d1
11111100
11111111
11111110
11100000
11000000
11000000
10000000
11000000
NAME Sugar 2 462
WAL true

TIL d2
10000000
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 463
WAL true

TIL d3
00000000
00000000
00000000
11000000
11100000
11111000
11111100
11111110
NAME Sugar 2 464
WAL true

TIL d4
00000000
00000000
00000000
00000000
00000000
00000011
00000011
00001111
NAME Sugar 2 465
WAL true

TIL d5
00000111
00011111
00111111
01111111
11111111
11111111
11111111
11111111
NAME Sugar 2 466
WAL true

TIL d6
11111111
11111111
11111111
11111111
11101111
10001111
00011111
11111111
NAME Sugar 2 467
WAL true

TIL d7
11000000
11000000
11000000
11000011
11100111
11100111
11111111
11111111
NAME Sugar 2 468
WAL true

TIL d8
00001111
00001111
00011111
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 469
WAL true

TIL d9
11111111
11001111
11000001
11110101
11111111
11111111
11111111
11111111
NAME Sugar 2 470
WAL true

TIL da
11111111
11111111
11111111
11111111
11111111
11111101
11111111
11111111
NAME Sugar 2 471
WAL true

TIL db
00000000
10000000
11100000
11100000
11111000
11111100
11111110
11111111
NAME Sugar 2 472
WAL true

TIL dc
00001111
00011111
00111111
01111111
01111111
01111111
11111111
11111111
NAME Sugar 2 473
WAL true

TIL dd
00000000
11000000
11000000
11100000
11100000
11100000
11110000
11110000
NAME Sugar 2 474
WAL true

TIL de
11111111
11111111
11111111
11111110
11111110
11111011
11111001
11111111
NAME Sugar 2 475
WAL true

TIL df
11111111
11111111
11111111
00111111
00111111
11111111
11111111
11111111
NAME Sugar 2 476
WAL true

TIL dg
11110000
11111000
11110000
11110000
11110000
11110000
11111000
11111000
NAME Sugar 2 477
WAL true

TIL dh
00000111
00000111
00000111
00000111
00000011
00000111
00000011
00000011
NAME Sugar 2 478
WAL true

TIL di
11111111
11101111
11110111
11111111
11111111
11111111
11100111
11111111
NAME Sugar 2 479
WAL true

TIL dj
11111111
11111111
11111011
11111111
11111111
11111111
11111111
11111111
NAME Sugar 2 480
WAL true

TIL dk
00000001
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 481
WAL true

TIL dl
11111111
11111111
11111111
11111011
11111111
11111111
11111111
11111111
NAME Sugar 2 482
WAL true

TIL dm
11111111
11111111
11111111
11111110
11111100
11111000
11100000
10000000
NAME Sugar 2 483
WAL true

TIL dn
00111101
00101111
00111111
00111111
00111111
00011111
00000011
00000111
NAME Sugar 2 484
WAL true

TIL do
11111000
11110000
11100000
11100000
11100000
11100000
11000000
11000000
NAME Sugar 2 485
WAL true

TIL dp
01111111
00111111
00111111
00011111
00001111
00000111
00000111
00000011
NAME Sugar 2 486
WAL true

TIL dq
11111111
11110010
11110000
11110100
11111100
11111100
11111100
11111000
NAME Sugar 2 487
WAL true

TIL dr
11111111
11111111
01111111
00111111
00000100
00000000
00000000
00000001
NAME Sugar 2 488
WAL true

TIL ds
11111111
11111111
11111111
11011111
00111111
01111111
11111111
11111111
NAME Sugar 2 489
WAL true

TIL dt
11111111
11111111
11111111
11111111
11111000
11111110
11111111
11111110
NAME Sugar 2 490
WAL true

TIL du
10000000
10100000
10000000
10000000
00000000
00000000
00000000
00000000
NAME Sugar 2 491
WAL true

TIL dv
00000111
00000011
00000011
00000011
00000011
00000011
00000001
00000000
NAME Sugar 2 492
WAL true

TIL dw
11111111
11111110
11111110
11111000
11100000
11000000
10000000
00000000
NAME Sugar 2 493
WAL true

TIL dx
11111111
11111111
01111111
00111111
00011111
00001111
00000011
00000000
NAME Sugar 2 494
WAL true

TIL dy
11111111
11111111
11111111
11111111
11111111
11111111
10111110
00000000
NAME Sugar 2 495
WAL true

TIL dz
11110000
11110000
11110000
11110000
11100000
10000000
00000000
00000000
NAME Sugar 2 496
WAL true

TIL e0
11111111
00111111
00000000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 497
WAL true

TIL e1
10011111
10011111
00011111
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 498
WAL true

TIL e2
11111100
11111000
11100000
00000000
00000000
00000000
00000000
00000000
NAME Sugar 2 499
WAL true

TIL e3
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL e4
00011000
01111110
01111111
01111111
01111110
11111111
11100000
00100000

TIL e5
11111111
00000001
00000001
00011001
00011001
00000001
00000001
00000001
WAL true

TIL e6
10000000
10000000
10000000
10011000
10011000
10000000
10000000
11111111
WAL true

TIL e7
00000000
00011000
00011000
01111110
01111110
00011000
00011000
00000000

TIL e9
00000000
00010000
00001000
00000100
00000100
00001000
00010000
00000000
NAME arrow

SPR A
00011000
00011000
00011000
10111100
01111110
00111101
00100100
00100100
POS 0 4,4

SPR a
00000000
00000100
00010010
01110001
11110010
01111100
00111100
00100100
>
00000000
00000010
00010001
01110001
11110010
01111100
00111100
00100100
DLG SPR_0
POS 0 11,8

SPR b
00000000
00000000
00000110
01000001
11000001
11111110
01111110
00100100
>
00000000
00000110
00000001
01000001
11000001
11111110
01111110
00100100
DLG SPR_1

SPR c
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

SPR d
00011000
00100101
01000010
01000010
01000010
00100101
00011000
00011000
>
00011000
10100100
01000010
01000010
01000010
10100100
00011000
00011000
DLG SPR_2
POS 1 7,4

SPR e
00111000
00111000
01010100
00111000
00111000
01111100
00101000
00101000
>
00111000
01111100
00010000
00111000
00111000
01111100
00101000
00101000
POS 4 6,11

SPR f
11111111
10000001
10111101
10000001
10110101
10000001
11111111
00011000
>
11111111
10000001
10111101
10000001
10110001
10000001
11111111
00011000
DLG SPR_3
POS 4 11,4

SPR g
00100000
00011111
00001111
00111111
11111011
11100011
11111111
11111111
>
00000000
00000111
00001111
10111111
11111011
11100011
11111111
11111111
DLG SPR_4
POS 3 8,9

ITM 0
00000110
00001111
00010010
00111110
01101100
01111100
01101100
00001100
NAME laptop
DLG ITM_0

ITM 1
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

ITM 2
00000000
00000000
00010100
00011100
00111110
00000000
00000000
00000000
>
00000000
00000000
00010100
00011100
00110110
00000000
00000000
00000000
NAME mousebrain
DLG ITM_1

DLG SPR_0
"""
{shk}{clr3}I'm a mouse{clr3}{shk}{shuffle
  - Im a young mouse!
  - Im staying by these edges!
}
"""

DLG ITM_0
You found the lab laptop

DLG SPR_1
I'm just going to rest here...

DLG SPR_2
"""
Im a close-up of a neuron! You can see where lots of my friends{sequence
  - live by seeing the blue shading that represents glucose activity!
  - 
}{
  - {item "0"} == 1 ?

  - else ?

}
"""

DLG SPR_3
"""
You've won an award for helping with mental illness!{sequence
  - Go get your big pharma reward!
  - 
}
"""

DLG SPR_4
Hurry! slice your mouse brain in here! Or the poor thing will die in vain! Now go look at it under the microscope

DLG ITM_1
"""
{
  - {item "0"} == 1 ?
    Quickly a brave mouse has donated it's previously active brain state! Onward to the mouse slicing room!
  - else ?
    Oh look something died...
}
"""

END 0
Well done you managed to isolate a chemical to control glucose in a very specific part of the brain! 

VAR a
42


</script>

<style>
html {
	margin:0px;
	padding:0px;
}

body {
	margin:0px;
	padding:0px;
	overflow:hidden;
	background:#ffffff;
}

#game {
	background:black;
	width:100vw;
	max-width:100vh;
	margin:auto;
	display:block;
}
</style>

<!-- SCRIPTS -->
<script>
function startExportedGame() {
	attachCanvas( document.getElementById("game") );
	load_game( document.getElementById("exportedGameData").text.slice(1) );
}
</script>

<script>
//hex-to-rgb method borrowed from stack overflow
function hexToRgb(hex) {
	// Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
	var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
	hex = hex.replace(shorthandRegex, function(m, r, g, b) {
		return r + r + g + g + b + b;
	});

	var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	return result ? {
		r: parseInt(result[1], 16),
		g: parseInt(result[2], 16),
		b: parseInt(result[3], 16)
	} : null;
}
function componentToHex(c) {
    var hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
}
function rgbToHex(r, g, b) {
    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}

function hslToHex(h,s,l) {
    var rgbArr = hslToRgb(h,s,l);
    return rgbToHex( Math.floor(rgbArr[0]), Math.floor(rgbArr[1]), Math.floor(rgbArr[2]) );
}

function hexToHsl(hex) {
    var rgb = hexToRgb(hex);
    return rgbToHsl(rgb.r, rgb.g, rgb.b);
}

// really just a vector distance
function colorDistance(a1,b1,c1,a2,b2,c2) {
    return Math.sqrt( Math.pow(a1 - a2, 2) + Math.pow(b1 - b2, 2) + Math.pow(c1 - c2, 2) );
}

function hexColorDistance(hex1,hex2) {
    var color1 = hexToRgb(hex1);
    var color2 = hexToRgb(hex2);
    return rgbColorDistance(color1.r, color1.g, color1.b, color2.r, color2.g, color2.b);
}


// source : http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
/* accepts parameters
 * h  Object = {h:x, s:y, v:z}
 * OR 
 * h, s, v
*/
function HSVtoRGB(h, s, v) {
    var r, g, b, i, f, p, q, t;
    if (arguments.length === 1) {
        s = h.s, v = h.v, h = h.h;
    }
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v, g = t, b = p; break;
        case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break;
        case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break;
        case 5: r = v, g = p, b = q; break;
    }
    return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
    };
}

/* accepts parameters
 * r  Object = {r:x, g:y, b:z}
 * OR 
 * r, g, b
*/
function RGBtoHSV(r, g, b) {
    if (arguments.length === 1) {
        g = r.g, b = r.b, r = r.r;
    }
    var max = Math.max(r, g, b), min = Math.min(r, g, b),
        d = max - min,
        h,
        s = (max === 0 ? 0 : d / max),
        v = max / 255;

    switch (max) {
        case min: h = 0; break;
        case r: h = (g - b) + d * (g < b ? 6: 0); h /= 6 * d; break;
        case g: h = (b - r) + d * 2; h /= 6 * d; break;
        case b: h = (r - g) + d * 4; h /= 6 * d; break;
    }

    return {
        h: h,
        s: s,
        v: v
    };
}

// source : https://gist.github.com/mjackson/5311256
/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * @param   Number  h       The hue
 * @param   Number  s       The saturation
 * @param   Number  l       The lightness
 * @return  Array           The RGB representation
 */
function hslToRgb(h, s, l) {
  var r, g, b;

  if (s == 0) {
    r = g = b = l; // achromatic
  } else {
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }

    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;

    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return [ r * 255, g * 255, b * 255 ];
}

/**
 * From: http://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
 *
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and l in the set [0, 1].
 *
 * @param   {number}  r       The red color value
 * @param   {number}  g       The green color value
 * @param   {number}  b       The blue color value
 * @return  {Array}           The HSL representation
 */
function rgbToHsl(r, g, b){
    r /= 255, g /= 255, b /= 255;
    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min){
        h = s = 0; // achromatic
    }else{
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max){
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }

    return [h, s, l];
}
</script>

<script>
/*
TODO:
- untangle local & external resource use in font manager (still more to do here)
*/

function FontManager(useExternalResources) {

if (useExternalResources === undefined || useExternalResources === null) {
	useExternalResources = false;
}

var self = this;

var fontExtension = ".bitsyfont";
this.GetExtension = function() {
	return fontExtension;
}

// place to store font data that is part of the local game data
var localResources = {};

// place to store font data fetched from a server (only used in editor)
var externalResources = null;
if (useExternalResources) {
	externalResources = new ResourceLoader();// NOTE : this class doesn't exist in exported game
}

this.LoadResources = function(filenames, onLoadAll) {
	if (!useExternalResources)
		return;

	// TODO : is this being called too many times?
	var onLoad = function() {
		var count = externalResources.getResourceLoadedCount();

		if (count >= filenames.length && onLoadAll != null) {
			onLoadAll();
		}
	}

	for (var i = 0; i < filenames.length; i++) {
		externalResources.load("bitsyfont", filenames[i], onLoad);
	}
}

// manually add resource
this.AddResource = function(filename, fontdata) {
	if (useExternalResources) {
		externalResources.set(filename, fontdata);
	}
	else {
		localResources[filename] = fontdata;
	}
}

this.ContainsResource = function(filename) {
	if (useExternalResources) {
		return externalResources.contains(filename);
	}
	else {
		return localResources[filename] != null;
	}
}

function GetData(fontName) {
	if (useExternalResources) {
		return externalResources.get(fontName + fontExtension);
	}
	else {
		return localResources[fontName + fontExtension];
	}
}
this.GetData = GetData;

function Create(fontData) {
	return new Font(fontData);
}
this.Create = Create;

this.Get = function(fontName) {
	var fontData = self.GetData(fontName);
	return self.Create(fontData);
}

function Font(fontData) {
	var name = "unknown";
	var width = 6; // default size so if you have NO font or an invalid font it displays boxes
	var height = 8;
	var chardata = {};
	var invalidCharData = {};

	this.getName = function() {
		return name;
	}

	this.getData = function() {
		return chardata;
	}

	this.getWidth = function() {
		return width;
	}

	this.getHeight = function() {
		return height;
	}

	this.hasChar = function(char) {
		var codepoint = char.charCodeAt(0);
		return chardata[codepoint] != null;
	}

	this.getChar = function(char) {

		var codepoint = char.charCodeAt(0);

		if (chardata[codepoint] != null) {
			return chardata[codepoint];
		}
		else {
			return invalidCharData;
		}
	}

	this.allCharCodes = function() {
		var codeList = [];
		for (var code in chardata) {
			codeList.push(code);
		}
		return codeList;
	}

	function parseFont(fontData) {
		if (fontData == null)
			return;

		var lines = fontData.split("\n");

		var isReadingChar = false;
		var isReadingCharProperties = false;
		var curCharLineCount = 0;
		var curCharCode = 0;

		for (var i = 0; i < lines.length; i++) {
			var line = lines[i];

			if (line[0] === "#") {
				continue; // skip comment lines
			}

			if (!isReadingChar) {
				// READING NON CHARACTER DATA LINE
				var args = line.split(" ");
				if (args[0] == "FONT") {
					name = args[1];
				}
				else if (args[0] == "SIZE") {
					width = parseInt(args[1]);
					height = parseInt(args[2]);
				}
				else if (args[0] == "CHAR") {
					isReadingChar = true;
					isReadingCharProperties = true;

					curCharLineCount = 0;
					curCharCode = parseInt(args[1]);
					chardata[curCharCode] = { 
						width: width,
						height: height,
						offset: {
							x: 0,
							y: 0
						},
						spacing: width,
						data: []
					};
				}
			}
			else {
				// CHAR PROPERTIES
				if (isReadingCharProperties) {
					var args = line.split(" ");
					if (args[0].indexOf("CHAR_") == 0) { // Sub-properties start with "CHAR_"
						if (args[0] == "CHAR_SIZE") {
							// Custom character size - overrides the default character size for the font
							chardata[curCharCode].width = parseInt(args[1]);
							chardata[curCharCode].height = parseInt(args[2]);
							chardata[curCharCode].spacing = parseInt(args[1]); // HACK : assumes CHAR_SIZE is always declared first
						}
						else if (args[0] == "CHAR_OFFSET") {
							// Character offset - shift the origin of the character on the X or Y axis
							chardata[curCharCode].offset.x = parseInt(args[1]);
							chardata[curCharCode].offset.y = parseInt(args[2]);
						}
						else if (args[0] == "CHAR_SPACING") {
							// Character spacing:
							// specify total horizontal space taken up by the character
							// lets chars take up more or less space on a line than its bitmap does
							chardata[curCharCode].spacing = parseInt(args[1]);
						}
					}
					else {
						isReadingCharProperties = false;
					}
				}

				// CHAR DATA
				if (!isReadingCharProperties) {
					// READING CHARACTER DATA LINE
					for (var j = 0; j < chardata[curCharCode].width; j++)
					{
						chardata[curCharCode].data.push( parseInt(line[j]) );
					}

					curCharLineCount++;
					if (curCharLineCount >= height) {
						isReadingChar = false;
					}
				}
			}
		}

		// init invalid character box
		invalidCharData = { 
			width: width,
			height: height,
			offset: {
				x: 0,
				y: 0
			},
			spacing: width, // TODO : name?
			data: []
		};
		for (var y = 0; y < height; y++) {
			for (var x = 0; x < width; x++) {
				if (x < width-1 && y < height-1) {
					invalidCharData.data.push(1);
				}
				else {
					invalidCharData.data.push(0);
				}
			}
		}
	}

	parseFont(fontData);
}

} // FontManager
</script>

<script>
function Script() {

this.CreateInterpreter = function() {
	return new Interpreter();
};

this.CreateUtils = function() {
	return new Utils();
};

var Interpreter = function() {
	var env = new Environment();
	var parser = new Parser( env );

	this.SetDialogBuffer = function(buffer) { env.SetDialogBuffer( buffer ); };

	// TODO -- maybe this should return a string instead othe actual script??
	this.Compile = function(scriptName, scriptStr) {
		// console.log("COMPILE");
		var script = parser.Parse( scriptStr );
		env.SetScript( scriptName, script );
	}
	this.Run = function(scriptName, exitHandler) { // Runs pre-compiled script
		// console.log("RUN");
		env.GetScript( scriptName )
			.Eval( env, function() { if(exitHandler!=null) exitHandler(); } );

		// console.log("SERIALIZE!!!!");
		// console.log( env.GetScript( scriptName ).Serialize() );
	}
	this.Interpret = function(scriptStr, exitHandler) { // Compiles and runs code immediately
		// console.log("INTERPRET");
		var script = parser.Parse( scriptStr );
		script.Eval( env, function() { if(exitHandler!=null) exitHandler(); } );
	}
	this.HasScript = function(name) { return env.HasScript(name); };

	this.ResetEnvironment = function() {
		env = new Environment();
		parser = new Parser( env );
	}

	// TODO : move to utils?
	// for reading in dialog from the larger file format
	this.ReadDialogScript = function(lines, i) {
		return parser.ReadDialogScript(lines,i);
	}

	this.Parse = function(scriptStr) { // parses a script but doesn't save it
		return parser.Parse( scriptStr );
	}
	this.Eval = function(scripTree, exitHandler) { // runs a script stored externally
		scripTree.Eval( env, function() { if(exitHandler!=null) exitHandler(); } );
	}

	this.CreateExpression = function(expStr) {
		return parser.CreateExpression( expStr );
	}

	this.SetVariable = function(name,value,useHandler) {
		env.SetVariable(name,value,useHandler);
	}

	this.DeleteVariable = function(name,useHandler) {
		env.DeleteVariable(name,useHandler);
	}
	this.HasVariable = function(name) {
		return env.HasVariable(name);
	}

	this.SetOnVariableChangeHandler = function(onVariableChange) {
		env.SetOnVariableChangeHandler(onVariableChange);
	}
	this.GetVariableNames = function() {
		return env.GetVariableNames();
	}
	this.GetVariable = function(name) {
		return env.GetVariable(name);
	}
}


var Utils = function() {
	// for editor ui
	this.CreateDialogBlock = function(children,doIndentFirstLine) {
		if(doIndentFirstLine === undefined) doIndentFirstLine = true;
		var block = new BlockNode( BlockMode.Dialog, doIndentFirstLine );
		for(var i = 0; i < children.length; i++) {
			block.AddChild( children[i] );
		}
		return block;
	}

	this.ChangeSequenceType = function(oldSequence,type) {
		if(type === "sequence") {
			return new SequenceNode( oldSequence.options );
		}
		else if(type === "cycle") {
			return new CycleNode( oldSequence.options );
		}
		else if(type === "shuffle") {
			return new ShuffleNode( oldSequence.options );
		}
		return oldSequence;
	}

	this.CreateSequenceBlock = function() {
		var option1 = new BlockNode( BlockMode.Dialog, false /*doIndentFirstLine*/ );
		var option2 = new BlockNode( BlockMode.Dialog, false /*doIndentFirstLine*/ );
		var sequence = new SequenceNode( [ option1, option2 ] );
		var block = new BlockNode( BlockMode.Code );
		block.AddChild( sequence );
		return block;
	}

	this.CreateIfBlock = function() {
		var leftNode = new BlockNode( BlockMode.Code );
		leftNode.AddChild( new FuncNode("item", [new LiteralNode("0")] ) );
		var rightNode = new LiteralNode( 1 );
		var condition1 = new ExpNode("==", leftNode, rightNode );

		var condition2 = new ElseNode();

		var result1 = new BlockNode( BlockMode.Dialog );
		var result2 = new BlockNode( BlockMode.Dialog );

		var ifNode = new IfNode( [ condition1, condition2 ], [ result1, result2 ] );
		var block = new BlockNode( BlockMode.Code );
		block.AddChild( ifNode );
		return block;
	}
}


/* BUILT-IN FUNCTIONS */ // TODO: better way to encapsulate these?
function deprecatedFunc(environment,parameters,onReturn) {
	console.log("BITSY SCRIPT WARNING: Tried to use deprecated function");
	onReturn(null);
}

function printFunc(environment,parameters,onReturn) {
	// console.log("PRINT FUNC");
	// console.log(parameters);
	if( parameters[0] != undefined && parameters[0] != null ) {
		// console.log(parameters[0]);
		// console.log(parameters[0].toString());
		// var textStr = parameters[0].toString();
		var textStr = "" + parameters[0];
		// console.log(textStr);
		var onFinishHandler = function() {
			// console.log("FINISHED PRINTING ---- SCRIPT");
			onReturn(null);
		}; // called when dialog is finished printing
		environment.GetDialogBuffer().AddText( textStr, onFinishHandler );
	}
	else {
		onReturn(null);
	}
}

function linebreakFunc(environment,parameters,onReturn) {
	// console.log("LINEBREAK FUNC");
	environment.GetDialogBuffer().AddLinebreak();
	onReturn(null);
}

function printDrawingFunc(environment,parameters,onReturn) {
	var drawingId = parameters[0];
	environment.GetDialogBuffer().AddDrawing( drawingId, function() {
		onReturn(null);
	});
}

function printSpriteFunc(environment,parameters,onReturn) {
	var spriteId = parameters[0];
	if(names.sprite.has(spriteId)) spriteId = names.sprite.get(spriteId); // id is actually a name
	var drawingId = sprite[spriteId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printTileFunc(environment,parameters,onReturn) {
	var tileId = parameters[0];
	if(names.tile.has(tileId)) tileId = names.tile.get(tileId); // id is actually a name
	var drawingId = tile[tileId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printItemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];
	if(names.item.has(itemId)) itemId = names.item.get(itemId); // id is actually a name
	var drawingId = item[itemId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printFontFunc(environment, parameters, onReturn) {
	var allCharacters = "";
	var font = fontManager.Get( fontName );
	var codeList = font.allCharCodes();
	for (var i = 0; i < codeList.length; i++) {
		allCharacters += String.fromCharCode(codeList[i]) + " ";
	}
	printFunc(environment, [allCharacters], onReturn);
}

function itemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];
	if(names.item.has(itemId)) itemId = names.item.get(itemId); // id is actually a name
	var itemCount = player().inventory[itemId] ? player().inventory[itemId] : 0; // TODO : ultimately the environment should include a reference to the game state
	// console.log("ITEM FUNC " + itemId + " " + itemCount);
	onReturn(itemCount);
}

function addOrRemoveTextEffect(environment,name) {
	if( environment.GetDialogBuffer().HasTextEffect(name) )
		environment.GetDialogBuffer().RemoveTextEffect(name);
	else
		environment.GetDialogBuffer().AddTextEffect(name);
}

function rainbowFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"rbw");
	onReturn(null);
}

// TODO : should the colors use a parameter instead of special names?
function color1Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr1");
	onReturn(null);
}

function color2Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr2");
	onReturn(null);
}

function color3Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr3");
	onReturn(null);
}

function wavyFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"wvy");
	onReturn(null);
}

function shakyFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"shk");
	onReturn(null);
}

/* BUILT-IN OPERATORS */
function setExp(environment,left,right,onReturn) {
	// console.log("SET " + left.name);

	if(left.type != "variable") {
		// not a variable! return null and hope for the best D:
		onReturn( null );
		return;
	}

	right.Eval(environment,function(rVal) {
		environment.SetVariable( left.name, rVal );
		// console.log("VAL " + environment.GetVariable( left.name ) );
		left.Eval(environment,function(lVal) {
			onReturn( lVal );
		});
	});
}
function equalExp(environment,left,right,onReturn) {
	// console.log("EVAL EQUAL");
	// console.log(left);
	// console.log(right);
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal === rVal );
		});
	});
}
function greaterExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal > rVal );
		});
	});
}
function lessExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal < rVal );
		});
	});
}
function greaterEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal >= rVal );
		});
	});
}
function lessEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal <= rVal );
		});
	});
}
function multExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal * rVal );
		});
	});
}
function divExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal / rVal );
		});
	});
}
function addExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal + rVal );
		});
	});
}
function subExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal - rVal );
		});
	});
}

/* ENVIRONMENT */
var Environment = function() {
	var dialogBuffer = null;
	this.SetDialogBuffer = function(buffer) { dialogBuffer = buffer; };
	this.GetDialogBuffer = function() { return dialogBuffer; };

	var functionMap = new Map();
	functionMap.set("print", printFunc);
	functionMap.set("say", printFunc);
	functionMap.set("br", linebreakFunc);
	functionMap.set("item", itemFunc);
	functionMap.set("rbw", rainbowFunc);
	functionMap.set("clr1", color1Func);
	functionMap.set("clr2", color2Func);
	functionMap.set("clr3", color3Func);
	functionMap.set("wvy", wavyFunc);
	functionMap.set("shk", shakyFunc);
	functionMap.set("printSprite", printSpriteFunc);
	functionMap.set("printTile", printTileFunc);
	functionMap.set("printItem", printItemFunc);
	functionMap.set("debugOnlyPrintFont", printFontFunc); // DEBUG ONLY

	this.HasFunction = function(name) { return functionMap.has(name); };
	this.EvalFunction = function(name,parameters,onReturn) {
		// console.log(functionMap);
		// console.log(name);
		functionMap.get( name )( this, parameters, onReturn );
	}

	var variableMap = new Map();

	this.HasVariable = function(name) { return variableMap.has(name); };
	this.GetVariable = function(name) { return variableMap.get(name); };
	this.SetVariable = function(name,value,useHandler) {
		// console.log("SET VARIABLE " + name + " = " + value);
		if(useHandler === undefined) useHandler = true;
		variableMap.set(name, value);
		if(onVariableChangeHandler != null && useHandler)
			onVariableChangeHandler(name);
	};
	this.DeleteVariable = function(name,useHandler) {
		if(useHandler === undefined) useHandler = true;
		if(variableMap.has(name)) {
			variableMap.delete(name);
			if(onVariableChangeHandler != null && useHandler)
				onVariableChangeHandler(name);
		}
	};

	var operatorMap = new Map();
	operatorMap.set("=", setExp);
	operatorMap.set("==", equalExp);
	operatorMap.set(">", greaterExp);
	operatorMap.set("<", lessExp);
	operatorMap.set(">=", greaterEqExp);
	operatorMap.set("<=", lessEqExp);
	operatorMap.set("*", multExp);
	operatorMap.set("/", divExp);
	operatorMap.set("+", addExp);
	operatorMap.set("-", subExp);

	this.HasOperator = function(sym) { return operatorMap.get(sym); };
	this.EvalOperator = function(sym,left,right,onReturn) {
		operatorMap.get( sym )( this, left, right, onReturn );
	}

	var scriptMap = new Map();
	this.HasScript = function(name) { return scriptMap.has(name); };
	this.GetScript = function(name) { return scriptMap.get(name); };
	this.SetScript = function(name,script) { scriptMap.set(name, script); };

	var onVariableChangeHandler = null;
	this.SetOnVariableChangeHandler = function(onVariableChange) {
		onVariableChangeHandler = onVariableChange;
	}
	this.GetVariableNames = function() {
		return Array.from( variableMap.keys() );
	}
}

function leadingWhitespace(depth) {
	var str = "";
	for(var i = 0; i < depth; i++) {
		str += "  "; // two spaces per indent
	}
	// console.log("WHITESPACE " + depth + " ::" + str + "::");
	return str;
}

/* NODES */
var TreeRelationship = function() {
	this.parent = null;
	this.children = [];
	this.AddChild = function(node) {
		this.children.push( node );
		node.parent = this;
	};

	this.VisitAll = function(visitor) {
		visitor.Visit( this );
		for( var i = 0; i < this.children.length; i++ ) {
			this.children[i].VisitAll( visitor );
		}
	};
}

var BlockMode = {
	Code : "code",
	Dialog : "dialog"
};

var BlockNode = function(mode, doIndentFirstLine) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "block";
	this.mode = mode;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL BLOCK " + this.children.length);

		if( this.onEnter != null ) this.onEnter();

		var lastVal = null;
		var i = 0;
		function evalChildren(children,done) {
			if(i < children.length) {
				// console.log(">> CHILD " + i);
				children[i].Eval( environment, function(val) {
					// console.log("<< CHILD " + i);
					lastVal = val;
					i++;
					evalChildren(children,done);
				} );
			}
			else {
				done();
			}
		};
		var self = this;
		evalChildren( this.children, function() {
			if( self.onExit != null ) self.onExit();
			onReturn(lastVal);
		} );
	}

	if(doIndentFirstLine === undefined) doIndentFirstLine = true; // This is just for serialization

	this.Serialize = function(depth) {
		if(depth === undefined) depth = 0;

		// console.log("SERIALIZE BLOCK!!!");
		// console.log(depth);
		// console.log(doIndentFirstLine);

		var str = "";
		var lastNode = null;
		if (this.mode === BlockMode.Code) str += "{"; // todo: increase scope of Sym?
		for (var i = 0; i < this.children.length; i++) {

			var curNode = this.children[i];

			if(curNode.type === "block" && lastNode && lastNode.type === "block" && !isBlockWithNoNewline(curNode) && !isBlockWithNoNewline(lastNode))
				str += "\n";

			var shouldIndentFirstLine = (i == 0 && doIndentFirstLine);
			var shouldIndentAfterLinebreak = (lastNode && lastNode.type === "function" && lastNode.name === "br");
			if(this.mode === BlockMode.Dialog && (shouldIndentFirstLine || shouldIndentAfterLinebreak))
				str += leadingWhitespace(depth);
			str += curNode.Serialize(depth);
			lastNode = curNode;
		}
		if (this.mode === BlockMode.Code) str += "}";
		return str;
	}
}

function isBlockWithNoNewline(node) {
	return isTextEffectBlock(node) || isMultilineListBlock(node);
}

function isTextEffectBlock(node) {
	if(node.type === "block") {
		if(node.children.length > 0 && node.children[0].type === "function") {
			var func = node.children[0];
			if(func.name === "clr1" || func.name === "clr2" || func.name === "clr3" || func.name === "wvy" || func.name === "shk" || func.name === "rbw") {
				return true;
			}
		}
	}
	return false;
}

function isMultilineListBlock(node) {
	if(node.type === "block") {
		if(node.children.length > 0) {
			var child = node.children[0];
			if(child.type === "sequence" || child.type === "cycle" || child.type === "shuffle" || child.type === "if") {
				return true;
			}
		}
	}
	return false;
}

var FuncNode = function(name,arguments) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "function";
	this.name = name;
	this.arguments = arguments;

	this.Eval = function(environment,onReturn) {

		if( this.onEnter != null ) this.onEnter();

		// console.log("FUNC");
		// console.log(this.arguments);
		var argumentValues = [];
		var i = 0;
		function evalArgs(arguments,done) {
			if(i < arguments.length) {
				// Evaluate each argument
				arguments[i].Eval( environment, function(val) {
					argumentValues.push( val );
					i++;
					evalArgs(arguments,done);
				} );
			}
			else {
				done();
			}
		};
		var self = this; // hack to deal with scope
		evalArgs( this.arguments, function() {
			// Then evaluate the function
			// console.log("ARGS");
			// console.log(argumentValues);

			if( self.onExit != null ) self.onExit();

			environment.EvalFunction( self.name, argumentValues, onReturn );
		} );
	}

	this.Serialize = function(depth) {
		var isDialogBlock = this.parent.mode && this.parent.mode === BlockMode.Dialog;
		if(isDialogBlock && this.name === "print") {
			// TODO this could cause problems with "real" print functions
			return this.arguments[0].value; // first argument should be the text of the {print} func
		}
		else if(isDialogBlock && this.name === "br") {
			return "\n";
		}
		else {
			var str = "";
			str += this.name;
			for(var i = 0; i < this.arguments.length; i++) {
				str += " ";
				str += this.arguments[i].Serialize(depth);
			}
			return str;
		}
	}
}

var LiteralNode = function(value) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "literal";
	this.value = value;

	this.Eval = function(environment,onReturn) {
		onReturn(this.value);
	}

	this.Serialize = function(depth) {
		var str = "";

		if(this.value === null)
			return str;

		if(typeof this.value === "string") str += '"';
		str += this.value;
		if(typeof this.value === "string") str += '"';

		return str;
	}
}

var VarNode = function(name) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "variable";
	this.name = name;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL " + this.name + " " + environment.HasVariable(this.name) + " " + environment.GetVariable(this.name));
		if( environment.HasVariable(this.name) )
			onReturn( environment.GetVariable( this.name ) );
		else
			onReturn(null); // not a valid variable -- return null and hope that's ok
	} // TODO: might want to store nodes in the variableMap instead of values???

	this.Serialize = function(depth) {
		var str = "" + this.name;
		return str;
	}
}

var ExpNode = function(operator, left, right) {
	Object.assign( this, new TreeRelationship() );
	this.type = "operator";
	this.operator = operator;
	this.left = left;
	this.right = right;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL " + this.operator);
		var self = this; // hack to deal with scope
		environment.EvalOperator( this.operator, this.left, this.right, 
			function(val){
				// console.log("EVAL EXP " + self.operator + " " + val);
				onReturn(val);
			} );
		// NOTE : sadly this pushes a lot of complexity down onto the actual operator methods
	}

	this.Serialize = function(depth) {
		var isNegativeNumber = this.operator === "-" && this.left.type === "literal" && this.left.value === null;

		if(!isNegativeNumber) {
			var str = "";
			str += this.left.Serialize(depth);
			str += " " + this.operator + " ";
			str += this.right.Serialize(depth);
			return str;
		}
		else {
			return this.operator + this.right.Serialize(depth); // hacky but seems to work
		}
	}

	this.VisitAll = function(visitor) {
		visitor.Visit( this );
		if(this.left != null)
			this.left.VisitAll( visitor );
		if(this.right != null)
			this.right.VisitAll( visitor );
	};
}

var SequenceBase = function() {
	this.Serialize = function(depth) {
		var str = "";
		str += this.type + "\n";
		for (var i = 0; i < this.options.length; i++) {
			// console.log("SERIALIZE SEQUENCE ");
			// console.log(depth);
			str += leadingWhitespace(depth + 1) + Sym.List + " " + this.options[i].Serialize(depth + 2) + "\n";
		}
		str += leadingWhitespace(depth);
		return str;
	}

	this.VisitAll = function(visitor) {
		visitor.Visit( this );
		for( var i = 0; i < this.options.length; i++ ) {
			this.options[i].VisitAll( visitor );
		}
	};
}

var SequenceNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "sequence";
	this.options = options;

	var index = 0;
	this.Eval = function(environment,onReturn) {
		// console.log("SEQUENCE " + index);
		this.options[index].Eval( environment, onReturn );

		var next = index + 1;
		if(next < this.options.length)
			index = next;
	}
}

var CycleNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "cycle";
	this.options = options;

	var index = 0;
	this.Eval = function(environment,onReturn) {
		// console.log("CYCLE " + index);
		this.options[index].Eval( environment, onReturn );

		var next = index + 1;
		if(next < this.options.length)
			index = next;
		else
			index = 0;
	}
}

var ShuffleNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "shuffle";
	this.options = options;

	var optionsShuffled = [];
	function shuffle(options) {
		optionsShuffled = [];
		var optionsUnshuffled = options.slice();
		while(optionsUnshuffled.length > 0) {
			var i = Math.floor( Math.random() * optionsUnshuffled.length );
			optionsShuffled.push( optionsUnshuffled.splice(i,1)[0] );
		}
	}
	shuffle(this.options);

	var index = 0;
	this.Eval = function(environment,onReturn) {
		// OLD RANDOM VERSION
		// var index = Math.floor(Math.random() * this.options.length);
		// this.options[index].Eval( environment, onReturn );

		optionsShuffled[index].Eval( environment, onReturn );
		
		index++;
		if (index >= this.options.length) {
			shuffle(this.options);
			index = 0;
		}
	}
}

var IfNode = function(conditions, results, isSingleLine) {
	Object.assign( this, new TreeRelationship() );
	this.type = "if";
	this.conditions = conditions;
	this.results = results;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL IF");
		var i = 0;
		var self = this;
		function TestCondition() {
			// console.log("EVAL " + i);
			self.conditions[i].Eval(environment, function(val) {
				// console.log(val);
				if(val == true) {
					self.results[i].Eval(environment, onReturn);
				}
				else if(i+1 < self.conditions.length) {
					i++;
					TestCondition(); // test next condition
				}
				else {
					onReturn(null); // out of conditions and none were true
				}
			});
		};
		TestCondition();
	}

	if(isSingleLine === undefined) isSingleLine = false; // This is just for serialization

	this.Serialize = function(depth) {
		var str = "";
		if(isSingleLine) {
			str += this.conditions[0].Serialize() + " ? " + this.results[0].Serialize();
			if(this.conditions.length > 1 && this.conditions[1].type === "else")
				str += " : " + this.results[1].Serialize();
		}
		else {
			str += "\n";
			for (var i = 0; i < this.conditions.length; i++) {
				str += leadingWhitespace(depth + 1) + Sym.List + " " + this.conditions[i].Serialize(depth) + " ?\n";
				str += this.results[i].Serialize(depth + 2) + "\n";
			}
			str += leadingWhitespace(depth);
		}
		return str;
	}

	this.IsSingleLine = function() {
		return isSingleLine;
	}

	this.VisitAll = function(visitor) {
		visitor.Visit( this );
		for( var i = 0; i < this.conditions.length; i++ ) {
			this.conditions[i].VisitAll( visitor );
		}
		for( var i = 0; i < this.results.length; i++ ) {
			this.results[i].VisitAll( visitor );
		}
	};
}

var ElseNode = function() {
	Object.assign( this, new TreeRelationship() );
	this.type = "else";

	this.Eval = function(environment,onReturn) {
		onReturn(true);
	}

	this.Serialize = function() {
		return "else";
	}
}

var Sym = {
	// DialogOpen : "/\"",
	// DialogClose : "\"/",
	DialogOpen : '"""',
	DialogClose : '"""',
	CodeOpen : "{",
	CodeClose : "}",
	Linebreak : "\n", // just call it "break" ?
	Separator : ":",
	List : "-",
	String : '"'
};

var Parser = function(env) {
	var environment = env;

	this.Parse = function(scriptStr) {
		// console.log("NEW PARSE!!!!!!");

		// TODO : make this work for single-line, no dialog block scripts

		var state = new ParserState( new BlockNode(BlockMode.Dialog), scriptStr );

		if( state.MatchAhead(Sym.DialogOpen) ) {
			// multi-line dialog block
			var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );
			state = new ParserState( new BlockNode(BlockMode.Dialog), dialogStr );
			state = ParseDialog( state );
		}
		// else if( state.MatchAhead(Sym.CodeOpen) ) { // NOTE: This causes problems when you lead with a code block
		// 	// code-block: should this ever happen?
		// 	state = ParseCodeBlock( state );
		// }
		else {
			// single-line dialog block
			state = ParseDialog( state );
		}

		// console.log( state.rootNode );
		return state.rootNode;
	};

	this.ReadDialogScript = function(lines, i) {
		var scriptStr = "";
		if (lines[i] === Sym.DialogOpen) {
			scriptStr += lines[i] + "\n";
			i++;
			while(lines[i] != Sym.DialogClose) {
				scriptStr += lines[i] + "\n";
				i++;
			}
			scriptStr += lines[i];
			i++;
		}
		else {
			scriptStr += lines[i];
		}
		return { script:scriptStr, index:i };
	}

	var ParserState = function( rootNode, str ) {
		this.rootNode = rootNode;
		this.curNode = this.rootNode;

		var sourceStr = str;
		var i = 0;
		this.Index = function() { return i; };
		this.Count = function() { return sourceStr.length; };
		this.Done = function() { return i >= sourceStr.length; };
		this.Char = function() { return sourceStr[i]; };
		this.Step = function(n) { if(n===undefined) n=1; i += n; };
		this.MatchAhead = function(str) {
			// console.log(str);
			str = "" + str; // hack to turn single chars into strings
			// console.log(str);
			// console.log(str.length);
			for(var j = 0; j < str.length; j++) {
				if( i + j >= sourceStr.length )
					return false;
				else if( str[j] != sourceStr[i+j] )
					return false;
			}
			return true;
		}
		this.Peak = function(end) {
			var str = "";
			var j = i;
			// console.log(j);
			while(j < sourceStr.length && end.indexOf( sourceStr[j] ) == -1 ) {
				str += sourceStr[j];
				j++;
			}
			// console.log("PEAK ::" + str + "::");
			return str;
		}
		this.ConsumeBlock = function( open, close ) {
			var startIndex = i;

			var matchCount = 0;
			if( this.MatchAhead( open ) ) {
				matchCount++;
				this.Step( open.length );
			}

			while( matchCount > 0 && !this.Done() ) {
				if( this.MatchAhead( close ) ) {
					matchCount--;
					this.Step( close.length );
				}
				else if( this.MatchAhead( open ) ) {
					matchCount++;
					this.Step( open.length );
				}
				else {
					this.Step();
				}
			}

			// console.log("!!! " + startIndex + " " + i);

			return sourceStr.slice( startIndex + open.length, i - close.length );
		}
		this.Print = function() { /*console.log(sourceStr);*/ };
	};

	function ParseDialog(state) {
		// console.log("PARSE DIALOG");
		state.Print();

		// for linebreak logic: add linebreaks after lines with dialog or empty lines (if it's not the very first line)
		var hasBlock = false;
		var hasDialog = false;
		var isFirstLine = true;

		// console.log("---- PARSE DIALOG ----");

		var text = "";
		var addTextNode = function() {
			// console.log("TEXT " + text.length);
			if (text.length > 0) {
				// console.log("TEXT " + text);
				// console.log("text!!");
				// console.log([text]);

				state.curNode.AddChild( new FuncNode( "print", [new LiteralNode(text)] ) );
				text = "";

				hasDialog = true;
			}
		}

		while ( !state.Done() ) {

			if( state.MatchAhead(Sym.CodeOpen) ) {
				addTextNode();
				state = ParseCodeBlock( state );

				// console.log("CODE");

				var len = state.curNode.children.length;
				if(len > 0 && state.curNode.children[len-1].type === "block") {
					var block = state.curNode.children[len-1];
					if(isMultilineListBlock(block))
						hasDialog = true; // hack to get correct newline behavior for multiline blocks
				}

				hasBlock = true;
			}
			// NOTE: nested dialog blocks disabled for now
			// else if( state.MatchAhead(Sym.DialogOpen) ) {
			// 	addTextNode();
			// 	state = ParseDialogBlock( state ); // These can be nested (should they though???)

			// 	hasBlock = true;
			// }
			else {
				if ( state.MatchAhead(Sym.Linebreak) ) {
					addTextNode();

					/*
					NOTES:
					linebreaks SHOULD happen on
					- lines with text (including the first or last line)
					- empty lines (that are NOT the first or last line)
					linebreaks should NOT happen on
					- lines with only CODE blocks
					- empty FIRST or LAST lines

					also, apparently:
					- NEVER line break on the last line
					*/
					var isLastLine = (state.Index() + 1) == state.Count();
					// console.log("block " + hasBlock);
					// console.log("dialog " + hasDialog);
					var isEmptyLine = !hasBlock && !hasDialog;
					// console.log("empty " + isEmptyLine);
					var isValidEmptyLine = isEmptyLine && !(isFirstLine || isLastLine);
					// console.log("valid empty " + isValidEmptyLine);
					var shouldAddLinebreak = (hasDialog || isValidEmptyLine) && !isLastLine; // last clause is a hack (but it works - why?)
					// console.log("LINEBREAK? " + shouldAddLinebreak);
					if( shouldAddLinebreak ) {
						// console.log("NEWLINE");
						// console.log("empty? " + isEmptyLine);
						// console.log("dialog? " + hasDialog);
						state.curNode.AddChild( new FuncNode( "br", [] ) ); // use function or character?
					}

					// linebreak logic
					isFirstLine = false;
					hasBlock = false;
					hasDialog = false;

					text = "";
				}
				else {
					text += state.Char();
				}
				state.Step();
			}

		}
		addTextNode();

		// console.log("---- PARSE DIALOG ----");

		// console.log(state);
		return state;
	}

	function ParseDialogBlock(state) {
		var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );

		var dialogState = new ParserState( new BlockNode(BlockMode.Dialog), dialogStr );
		dialogState = ParseDialog( dialogState );

		state.curNode.AddChild( dialogState.rootNode );

		return state;
	}

	function ParseIf(state) {
		var conditionStrings = [];
		var resultStrings = [];
		var curIndex = -1;
		var isNewline = true;
		var isConditionDone = false;
		var codeBlockCount = 0;

		while( !state.Done() ) {
			if(state.Char() === Sym.CodeOpen)
				codeBlockCount++;
			else if(state.Char() === Sym.CodeClose)
				codeBlockCount--;

			var isWhitespace = (state.Char() === " " || state.Char() === "\t");
			var isSkippableWhitespace = isNewline && isWhitespace;
			var isNewListItem = isNewline && (codeBlockCount <= 0) && (state.Char() === Sym.List);

			if(isNewListItem) {
				curIndex++;
				isConditionDone = false;
				conditionStrings[curIndex] = "";
				resultStrings[curIndex] = "";
			}
			else if(curIndex > -1) {
				if(!isConditionDone) {
					if(state.Char() === "?" || state.Char() === "\n") { // TODO: use Sym
						// end of condition
						isConditionDone = true;
					}
					else {
						// read in condition
						conditionStrings[curIndex] += state.Char();
					}
				}
				else {
					// read in result
					if(!isSkippableWhitespace)
						resultStrings[curIndex] += state.Char();
				}
			}

			isNewline = (state.Char() === Sym.Linebreak) || isSkippableWhitespace || isNewListItem;

			state.Step();
		}

		// console.log("PARSE IF:");
		// console.log(conditionStrings);
		// console.log(resultStrings);

		var conditions = [];
		for(var i = 0; i < conditionStrings.length; i++) {
			var str = conditionStrings[i].trim();
			if(str === "else") {
				conditions.push( new ElseNode() );
			}
			else {
				var exp = CreateExpression( str );
				conditions.push( exp );
			}
		}

		var results = [];
		for(var i = 0; i < resultStrings.length; i++) {
			var str = resultStrings[i];
			var dialogBlockState = new ParserState( new BlockNode(BlockMode.Dialog), str );
			dialogBlockState = ParseDialog( dialogBlockState );
			var dialogBlock = dialogBlockState.rootNode;
			results.push( dialogBlock );
		}

		state.curNode.AddChild( new IfNode( conditions, results ) );

		return state;
	}

	function IsSequence(str) {
		// console.log("IsSequence? " + str);
		return str === "sequence" || str === "cycle" || str === "shuffle";
	}

	// TODO: don't forget about eating whitespace
	function ParseSequence(state, sequenceType) {
		// console.log("SEQUENCE " + sequenceType);
		state.Print();

		var isNewline = false;
		var itemStrings = [];
		var curItemIndex = -1; // -1 indicates not reading an item yet
		var codeBlockCount = 0;

		while( !state.Done() ) {
			if(state.Char() === Sym.CodeOpen)
				codeBlockCount++;
			else if(state.Char() === Sym.CodeClose)
				codeBlockCount--;

			var isWhitespace = (state.Char() === " " || state.Char() === "\t");
			var isSkippableWhitespace = isNewline && isWhitespace;
			var isNewListItem = isNewline && (codeBlockCount <= 0) && (state.Char() === Sym.List);

			if(isNewListItem) {
				// console.log("found next list item");
				curItemIndex++;
				itemStrings[curItemIndex] = "";
			}
			else if(curItemIndex > -1) {
				if(!isSkippableWhitespace)
					itemStrings[curItemIndex] += state.Char();
			}

			isNewline = (state.Char() === Sym.Linebreak) || isSkippableWhitespace || isNewListItem;

			// console.log(state.Char());
			state.Step();
		}
		// console.log(itemStrings);
		// console.log("SEQUENCE DONE");

		var options = [];
		for(var i = 0; i < itemStrings.length; i++) {
			var str = itemStrings[i];
			var dialogBlockState = new ParserState( new BlockNode( BlockMode.Dialog, false /* doIndentFirstLine */ ), str );
			dialogBlockState = ParseDialog( dialogBlockState );
			var dialogBlock = dialogBlockState.rootNode;
			options.push( dialogBlock );
		}

		// console.log(options);

		if(sequenceType === "sequence")
			state.curNode.AddChild( new SequenceNode( options ) );
		else if(sequenceType === "cycle")
			state.curNode.AddChild( new CycleNode( options ) );
		else if(sequenceType === "shuffle")
			state.curNode.AddChild( new ShuffleNode( options ) );

		return state;
	}

	function ParseFunction(state, funcName) {
		var args = [];

		var curSymbol = "";
		function OnSymbolEnd() {
			curSymbol = curSymbol.trim();
			// console.log("PARAMTER " + curSymbol);
			args.push( StringToValue(curSymbol) );
			// console.log(args);
			curSymbol = "";
		}

		while( !( state.Char() === "\n" || state.Done() ) ) {
			if( state.MatchAhead(Sym.CodeOpen) ) {
				var codeBlockState = new ParserState( new BlockNode(BlockMode.Code), state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose ) );
				codeBlockState = ParseCode( codeBlockState );
				var codeBlock = codeBlockState.rootNode;
				args.push( codeBlock );
				curSymbol = "";
			}
			else if( state.MatchAhead(Sym.String) ) {
				/* STRING LITERAL */
				var str = state.ConsumeBlock(Sym.String, Sym.String);
				// console.log("STRING " + str);
				args.push( new LiteralNode(str) );
				curSymbol = "";
			}
			else if(state.Char() === " " && curSymbol.length > 0) {
				OnSymbolEnd();
			}
			else {
				curSymbol += state.Char();
			}
			state.Step();
		}

		if(curSymbol.length > 0) {
			OnSymbolEnd();
		}

		state.curNode.AddChild( new FuncNode( funcName, args ) );

		return state;
	}

	function IsValidVariableName(str) {
		var reg = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
		var isValid = reg.test(str);
		// console.log("VALID variable??? " + isValid);
		return isValid;
	}

	function StringToValue(valStr) {
		if(valStr[0] === Sym.CodeOpen) {
			// CODE BLOCK!!!
			var codeStr = (new ParserState( null, valStr )).ConsumeBlock(Sym.CodeOpen, Sym.CodeClose); //hacky
			var codeBlockState = new ParserState( new BlockNode( BlockMode.Code ), codeStr );
			codeBlockState = ParseCode( codeBlockState );
			return codeBlockState.rootNode;
		}
		else if(valStr[0] === Sym.String) {
			// STRING!!
			// console.log("STRING");
			var str = "";
			var i = 1;
			while (i < valStr.length && valStr[i] != Sym.String) {
				str += valStr[i];
				i++;
			}
			// console.log(str);
			return new LiteralNode( str );
		}
		else if(valStr === "true") {
			// BOOL
			return new LiteralNode( true );
		}
		else if(valStr === "false") {
			// BOOL
			return new LiteralNode( false );
		}
		else if( !isNaN(parseFloat(valStr)) ) {
			// NUMBER!!
			// console.log("NUMBER!!! " + valStr);
			return new LiteralNode( parseFloat(valStr) );
		}
		else if(IsValidVariableName(valStr)) {
			// VARIABLE!!
			// console.log("VARIABLE");
			return new VarNode(valStr); // TODO : check for valid potential variables
		}
		else {
			// uh oh
			return new LiteralNode(null);
		}
	}

	var setSymbol = "=";
	var ifSymbol = "?";
	var elseSymbol = ":";
	// var operatorSymbols = ["==", ">", "<", ">=", "<=", "*", "/", "+", "-"];
	var operatorSymbols = ["-", "+", "/", "*", "<=", ">=", "<", ">", "=="]; // operators need to be in reverse order
	function CreateExpression(expStr) {
		expStr = expStr.trim();

		function IsInsideString(index) {
			var inString = false;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.String)
					inString = !inString;

				if(index === i)
					return inString;
			}
			return false;
		}

		function IsInsideCode(index) {
			var count = 0;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.CodeOpen)
					count++;
				else if(expStr[i] === Sym.CodeClose)
					count--;

				if(index === i)
					return count > 0;
			}
			return false;
		}
	
		var operator = null;

		// set is special because other operator can look like it, and it has to go first in the order of operations
		var setIndex = expStr.indexOf(setSymbol);
		if( setIndex > -1 && !IsInsideString(setIndex) && !IsInsideCode(setIndex) ) { // it might be a set operator
			if( expStr[setIndex+1] != "=" && expStr[setIndex-1] != ">" && expStr[setIndex-1] != "<" ) {
				// ok it actually IS a set operator and not ==, >=, or <=
				operator = setSymbol;
				var variableName = expStr.substring(0,setIndex).trim(); // TODO : valid variable name testing
				var left = IsValidVariableName(variableName) ? new VarNode( variableName ) : new LiteralNode(null);
				var right = CreateExpression( expStr.substring(setIndex+setSymbol.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		// special if "expression" for single-line if statements
		var ifIndex = expStr.indexOf(ifSymbol);
		if( ifIndex > -1 && !IsInsideString(ifIndex) && !IsInsideCode(ifIndex) ) {
			operator = ifSymbol;
			var conditionStr = expStr.substring(0,ifIndex).trim();
			var conditions = [ CreateExpression(conditionStr) ];

			var resultStr = expStr.substring(ifIndex+ifSymbol.length);
			var results = [];
			function AddResult(str) {
				var dialogBlockState = new ParserState( new BlockNode(BlockMode.Dialog), str );
				dialogBlockState = ParseDialog( dialogBlockState );
				var dialogBlock = dialogBlockState.rootNode;
				results.push( dialogBlock );
			}

			var elseIndex = resultStr.indexOf(elseSymbol); // does this need to test for strings?
			if(elseIndex > -1) {
				conditions.push( new ElseNode() );

				var elseStr = resultStr.substring(elseIndex+elseSymbol.length);
				var resultStr = resultStr.substring(0,elseIndex);

				AddResult( resultStr.trim() );
				AddResult( elseStr.trim() );
			}
			else {
				AddResult( resultStr.trim() );
			}

			return new IfNode( conditions, results, true /*isSingleLine*/ );
		}

		for( var i = 0; (operator == null) && (i < operatorSymbols.length); i++ ) {
			var opSym = operatorSymbols[i];
			var opIndex = expStr.indexOf( opSym );
			if( opIndex > -1 && !IsInsideString(opIndex) && !IsInsideCode(opIndex) ) {
				operator = opSym;
				var left = CreateExpression( expStr.substring(0,opIndex) );
				var right = CreateExpression( expStr.substring(opIndex+opSym.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		if( operator == null ) {
			return StringToValue(expStr);
		}
	}
	this.CreateExpression = CreateExpression;

	function ParseExpression(state) {
		var line = state.Peak( [Sym.Linebreak] );
		// console.log("EXPRESSION " + line);
		var exp = CreateExpression( line );
		// console.log(exp);
		state.curNode.AddChild( exp );
		state.Step( line.length );
		return state;
	}

	function ParseCode(state) {
		// TODO : how do I do this parsing??? one expression per block? or per line?
		while ( !state.Done() ) {

			if( state.Char() === " " || state.Char() === "\t" || state.Char() === "\n" ) { // TODO: symbols? IsWhitespace func?
				state.Step(); // consume whitespace
			}
			else if( state.MatchAhead(Sym.CodeOpen) ) {
				state = ParseCodeBlock( state );
			}
			// NOTE: nested dialog blocks disabled for now
			// else if( state.MatchAhead(Sym.DialogOpen) ) {
			// 	state = ParseDialogBlock( state ); // These can be nested (should they though???)
			// }
			else if( state.Char() === Sym.List && (state.Peak([]).indexOf("?") > -1) ) { // TODO : symbols? matchahead?
				// console.log("PEAK IF " + state.Peak( ["?"] ));
				state = ParseIf( state );
			}
			else if( environment.HasFunction( state.Peak( [" "] ) ) ) { // TODO --- what about newlines???
				var funcName = state.Peak( [" "] );
				state.Step( funcName.length );
				state = ParseFunction( state, funcName );
			}
			else if( IsSequence( state.Peak( [" ", Sym.Linebreak] ) ) ) {
				var sequenceType = state.Peak( [" ", Sym.Linebreak] );
				state.Step( sequenceType.length );
				state = ParseSequence( state, sequenceType );
			}
			else {
				state = ParseExpression( state );
			}
		}

		return state;
	}

	function ParseCodeBlock(state) {
		var codeStr = state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );

		// console.log("PARSE CODE");
		// console.log(codeStr);

		var codeState = new ParserState( new BlockNode(BlockMode.Code), codeStr );
		codeState = ParseCode( codeState );
		
		state.curNode.AddChild( codeState.rootNode );

		return state;
	}

}

} // Script()
</script>

<script>
function Dialog() {

this.CreateRenderer = function() {
	return new DialogRenderer();
};

this.CreateBuffer = function() {
	return new DialogBuffer();
};

var DialogRenderer = function() {

	// TODO : refactor this eventually? remove everything from struct.. avoid the defaults?
	var textboxInfo = {
		img : null,
		width : 104,
		height : 8+4+2+5, //8 for text, 4 for top-bottom padding, 2 for line padding, 5 for arrow
		top : 12,
		left : 12,
		bottom : 12, //for drawing it from the bottom
		font_scale : 0.5, // we draw font at half-size compared to everything else
		padding_vert : 2,
		padding_horz : 4,
		arrow_height : 5,
	};

	var font = null;
	this.SetFont = function(f) {
		font = f;
		textboxInfo.height = (textboxInfo.padding_vert * 3) + (relativeFontHeight() * 2) + textboxInfo.arrow_height;
		textboxInfo.img = context.createImageData(textboxInfo.width*scale, textboxInfo.height*scale);
	}

	function textScale() {
		return scale * textboxInfo.font_scale;
	}

	function relativeFontWidth() {
		return Math.ceil( font.getWidth() * textboxInfo.font_scale );
	}

	function relativeFontHeight() {
		return Math.ceil( font.getHeight() * textboxInfo.font_scale );
	}

	var context = null;
	this.AttachContext = function(c) {
		context = c;
	};

	this.ClearTextbox = function() {
		if(context == null) return;

		//create new image none exists
		if(textboxInfo.img == null)
			textboxInfo.img = context.createImageData(textboxInfo.width*scale, textboxInfo.height*scale);

		// fill text box with black
		for (var i=0;i<textboxInfo.img.data.length;i+=4)
		{
			textboxInfo.img.data[i+0]=0;
			textboxInfo.img.data[i+1]=0;
			textboxInfo.img.data[i+2]=0;
			textboxInfo.img.data[i+3]=255;
		}
	};

	var isCentered = false;
	this.SetCentered = function(centered) {
		isCentered = centered;
	};

	this.DrawTextbox = function() {
		if(context == null) return;
		if (isCentered) {
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, ((height/2)-(textboxInfo.height/2))*scale);
		}
		else if (player().y < mapsize/2) {
			//bottom
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, (height-textboxInfo.bottom-textboxInfo.height)*scale);
		}
		else {
			//top
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, textboxInfo.top*scale);
		}
	};

	var arrowdata = [
		1,1,1,1,1,
		0,1,1,1,0,
		0,0,1,0,0
	];
	this.DrawNextArrow = function() {
		// console.log("draw arrow!");
		var top = (textboxInfo.height-5) * scale;
		var left = (textboxInfo.width-(5+4)) * scale;
		if (textDirection === TextDirection.RightToLeft) { // RTL hack
			left = 4 * scale;
		}

		for (var y = 0; y < 3; y++) {
			for (var x = 0; x < 5; x++) {
				var i = (y * 5) + x;
				if (arrowdata[i] == 1) {
					//scaling nonsense
					for (var sy = 0; sy < scale; sy++) {
						for (var sx = 0; sx < scale; sx++) {
							var pxl = 4 * ( ((top+(y*scale)+sy) * (textboxInfo.width*scale)) + (left+(x*scale)+sx) );
							textboxInfo.img.data[pxl+0] = 255;
							textboxInfo.img.data[pxl+1] = 255;
							textboxInfo.img.data[pxl+2] = 255;
							textboxInfo.img.data[pxl+3] = 255;
						}
					}
				}
			}
		}
	};

	var text_scale = 2; //using a different scaling factor for text feels like cheating... but it looks better
	this.DrawChar = function(char, row, col, leftPos) {
		char.offset = {
			x: char.base_offset.x,
			y: char.base_offset.y
		}; // compute render offset *every* frame

		char.SetPosition(row,col);
		char.ApplyEffects(effectTime);

		var charData = char.bitmap;

		var top = (4 * scale) + (row * 2 * scale) + (row * font.getHeight() * text_scale) + Math.floor( char.offset.y );
		var left = (4 * scale) + (leftPos * text_scale) + Math.floor( char.offset.x );

		var debug_r = Math.random() * 255;

		for (var y = 0; y < char.height; y++) {
			for (var x = 0; x < char.width; x++) {

				var i = (y * char.width) + x;
				if ( charData[i] == 1 ) {

					//scaling nonsense
					for (var sy = 0; sy < text_scale; sy++) {
						for (var sx = 0; sx < text_scale; sx++) {
							var pxl = 4 * ( ((top+(y*text_scale)+sy) * (textboxInfo.width*scale)) + (left+(x*text_scale)+sx) );
							textboxInfo.img.data[pxl+0] = char.color.r;
							textboxInfo.img.data[pxl+1] = char.color.g;
							textboxInfo.img.data[pxl+2] = char.color.b;
							textboxInfo.img.data[pxl+3] = char.color.a;
						}
					}
				}
				// else {
				// 	// DEBUG

				// 	//scaling nonsense
				// 	for (var sy = 0; sy < text_scale; sy++) {
				// 		for (var sx = 0; sx < text_scale; sx++) {
				// 			var pxl = 4 * ( ((top+(y*text_scale)+sy) * (textboxInfo.width*scale)) + (left+(x*text_scale)+sx) );
				// 			textboxInfo.img.data[pxl+0] = debug_r;
				// 			textboxInfo.img.data[pxl+1] = 0;
				// 			textboxInfo.img.data[pxl+2] = 0;
				// 			textboxInfo.img.data[pxl+3] = 255;
				// 		}
				// 	}
				// }

			}
		}
		
		// call printHandler for character
		char.OnPrint();
	};

	var effectTime = 0; // TODO this variable should live somewhere better
	this.Draw = function(buffer,dt) {
		effectTime += dt;

		this.ClearTextbox();

		buffer.ForEachActiveChar( this.DrawChar );

		if( buffer.CanContinue() )
			this.DrawNextArrow();

		this.DrawTextbox();

		if( buffer.DidPageFinishThisFrame() && onPageFinish != null )
			onPageFinish();
	};

	/* this is a hook for GIF rendering */
	var onPageFinish = null;
	this.SetPageFinishHandler = function(handler) {
		onPageFinish = handler;
	};

	this.Reset = function() {
		effectTime = 0;
		// TODO - anything else?
	}

	// this.CharsPerRow = function() {
	// 	return textboxInfo.charsPerRow;
	// }
}


var DialogBuffer = function() {
	var buffer = [[[]]]; // holds dialog in an array buffer
	var pageIndex = 0;
	var rowIndex = 0;
	var charIndex = 0;
	var nextCharTimer = 0;
	var nextCharMaxTime = 50; // in milliseconds
	var isDialogReadyToContinue = false;
	var activeTextEffects = [];
	var font = null;
	var arabicHandler = new ArabicHandler();

	this.SetFont = function(f) {
		font = f;
	}

	this.CurPage = function() { return buffer[ pageIndex ]; };
	this.CurRow = function() { return this.CurPage()[ rowIndex ]; };
	this.CurChar = function() { return this.CurRow()[ charIndex ]; };
	this.CurPageCount = function() { return buffer.length; };
	this.CurRowCount = function() { return this.CurPage().length; };
	this.CurCharCount = function() { return this.CurRow().length; };

	this.ForEachActiveChar = function(handler) { // Iterates over visible characters on the active page
		var rowCount = rowIndex + 1;
		for (var i = 0; i < rowCount; i++) {
			var row = this.CurPage()[i];
			var charCount = (i == rowIndex) ? charIndex+1 : row.length;
			// console.log(charCount);

			var leftPos = 0;
			if (textDirection === TextDirection.RightToLeft) {
				leftPos = 24 * 8; // hack -- I think this is correct?
			}

			for(var j = 0; j < charCount; j++) {
				var char = row[j];
				if(char) {
					if (textDirection === TextDirection.RightToLeft) {
						leftPos -= char.spacing;
					}
					// console.log(j + " " + leftPos);

					// handler( char, i /*rowIndex*/, j /*colIndex*/ );
					handler(char, i /*rowIndex*/, j /*colIndex*/, leftPos)

					if (textDirection === TextDirection.LeftToRight) {
						leftPos += char.spacing;
					}
				}
			}
		}
	}

	this.Reset = function() {
		buffer = [[[]]];
		pageIndex = 0;
		rowIndex = 0;
		charIndex = 0;
		isDialogReadyToContinue = false;

		activeTextEffects = [];

		isActive = false;
	};

	this.DoNextChar = function() {
		// console.log("DO NEXT CHAR");

		nextCharTimer = 0; //reset timer

		//time to update characters
		if (charIndex + 1 < this.CurCharCount()) {
			//add char to current row
			charIndex++;
		}
		else if (rowIndex + 1 < this.CurRowCount()) {
			//start next row
			rowIndex++;
			charIndex = 0;
		}
		else {
			//the page is full!
			isDialogReadyToContinue = true;
			didPageFinishThisFrame = true;

			// console.log("WAITING FOR INPUT");
		}

		// console.log(this.CurChar());
		if(this.CurChar() != null)
			this.CurChar().OnPrint(); // make sure we hit the callback before we run out of text
	};

	this.Update = function(dt) {
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// this.Draw(dt); // TODO move into a renderer object
		if (isDialogReadyToContinue) {
			return; //waiting for dialog to be advanced by player
		}

		nextCharTimer += dt; //tick timer

		if (nextCharTimer > nextCharMaxTime) {
			this.DoNextChar();
		}
	};

	this.Skip = function() {
		console.log("SKIPPP");
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// add new characters until you get to the end of the current line of dialog
		while (rowIndex < this.CurRowCount()) {
			this.DoNextChar();

			if(isDialogReadyToContinue) {
				//make sure to push the rowIndex past the end to break out of the loop
				rowIndex++;
				charIndex = 0;
			}
		}
		rowIndex = this.CurRowCount()-1;
		charIndex = this.CurCharCount()-1;
	};

	this.FlipPage = function() {
		didFlipPageThisFrame = true;
		isDialogReadyToContinue = false;
		pageIndex++;
		rowIndex = 0;
		charIndex = 0;
	}

	this.EndDialog = function() {
		console.log("END!!!!");
		isActive = false; // no more text to show... this should be a sign to stop rendering dialog
	}

	this.Continue = function() {
		console.log("CONTINUE");
		if (pageIndex + 1 < this.CurPageCount()) {
			//start next page
			this.FlipPage();
			return true; /* hasMoreDialog */
		}
		else {
			//end dialog mode
			this.EndDialog();
			return false; /* hasMoreDialog */
		}
	};

	var isActive = false;
	this.IsActive = function() { return isActive; };

	this.CanContinue = function() { return isDialogReadyToContinue; };

	function DialogChar(effectList) {
		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)

		this.color = { r:255, g:255, b:255, a:255 };
		this.offset = { x:0, y:0 }; // in pixels (screen pixels?)

		this.col = 0;
		this.row = 0;

		this.SetPosition = function(row,col) {
			// console.log("SET POS");
			// console.log(this);
			this.row = row;
			this.col = col;
		}

		this.ApplyEffects = function(time) {
			// console.log("APPLY EFFECTS! " + time);
			for(var i = 0; i < this.effectList.length; i++) {
				var effectName = this.effectList[i];
				// console.log("FX " + effectName);
				TextEffects[ effectName ].DoEffect( this, time );
			}
		}

		var printHandler = null; // optional function to be called once on printing character
		this.SetPrintHandler = function(handler) {
			printHandler = handler;
		}
		this.OnPrint = function() {
			if (printHandler != null) {
				console.log("PRINT HANDLER ---- DIALOG BUFFER");
				printHandler();
				printHandler = null; // only call handler once (hacky)
			}
		}

		this.bitmap = [];
		this.width = 0;
		this.height = 0;
		this.base_offset = { // hacky name
 			x: 0,
			y: 0
		};
		this.spacing = 0;
	}

	function DialogFontChar(font, char, effectList) {
		Object.assign(this, new DialogChar(effectList));

		var charData = font.getChar(char);
		this.bitmap = charData.data;
		this.width = charData.width;
		this.height = charData.height;
		this.base_offset.x = charData.offset.x;
		this.base_offset.y = charData.offset.y;
		this.spacing = charData.spacing;
	}

	function DialogDrawingChar(drawingId, effectList) {
		Object.assign(this, new DialogChar(effectList));

		var imageData = renderer.GetImageSource(drawingId)[0];
		var imageDataFlat = [];
		for (var i = 0; i < imageData.length; i++) {
			// console.log(imageData[i]);
			imageDataFlat = imageDataFlat.concat(imageData[i]);
		}

		this.bitmap = imageDataFlat;
		this.width = 8;
		this.height = 8;
		this.spacing = 8;
	}

	function AddWordToCharArray(charArray,word,effectList) {
		for(var i = 0; i < word.length; i++) {
			charArray.push( new DialogFontChar( font, word[i], effectList ) );
		}
		return charArray;
	}

	function GetCharArrayWidth(charArray) {
		var width = 0;
		for(var i = 0; i < charArray.length; i++) {
			width += charArray[i].spacing;
		}
		return width;
	}

	function GetStringWidth(str) {
		var width = 0;
		for (var i = 0; i < str.length; i++) {
			var charData = font.getChar(str[i]);
			width += charData.spacing;
		}
		return width;
	}

	var pixelsPerRow = 192; // hard-coded fun times!!!

	this.AddDrawing = function(drawingId, onFinishHandler) {
		// console.log("DRAWING ID " + drawingId);

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var drawingChar = new DialogDrawingChar(drawingId, activeTextEffects)
		drawingChar.SetPrintHandler( onFinishHandler );

		var rowLength = GetCharArrayWidth(curRowArr);

		// TODO : clean up copy-pasted code here :/
		if (rowLength + drawingChar.spacing  <= pixelsPerRow || rowLength <= 0)
		{
			//stay on same row
			curRowArr.push( drawingChar );
		}
		else if (curRowIndex == 0)
		{
			//start next row
			buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
			buffer[ curPageIndex ].push( [] );
			curRowIndex++;
			curRowArr = buffer[ curPageIndex ][ curRowIndex ];
			curRowArr.push( drawingChar );
		}
		else {
			//start next page
			buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
			buffer.push( [] );
			curPageIndex++;
			buffer[ curPageIndex ].push( [] );
			curRowIndex = 0;
			curRowArr = buffer[ curPageIndex ][ curRowIndex ];
			curRowArr.push( drawingChar );
		}

		isActive = true; // this feels like a bad way to do this???
	}

	// TODO : convert this into something that takes DialogChar arrays
	this.AddText = function(textStr,onFinishHandler) {
		// console.log("ADD TEXT " + textStr);

		//process dialog so it's easier to display
		var words = textStr.split(" ");

		// var curPageIndex = this.CurPageCount() - 1;
		// var curRowIndex = this.CurRowCount() - 1;
		// var curRowArr = this.CurRow();

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		for (var i = 0; i < words.length; i++) {
			var word = words[i];
			if (arabicHandler.ContainsArabicCharacters(word)) {
				word = arabicHandler.ShapeArabicCharacters(word);
			}

			var wordWithPrecedingSpace = ((i == 0) ? "" : " ") + word;
			var wordLength = GetStringWidth( wordWithPrecedingSpace );

			var rowLength = GetCharArrayWidth(curRowArr);

			if (rowLength + wordLength <= pixelsPerRow || rowLength <= 0) {
				//stay on same row
				curRowArr = AddWordToCharArray( curRowArr, wordWithPrecedingSpace, activeTextEffects );
			}
			else if (curRowIndex == 0) {
				//start next row
				buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
				buffer[ curPageIndex ].push( [] );
				curRowIndex++;
				curRowArr = buffer[ curPageIndex ][ curRowIndex ];
				curRowArr = AddWordToCharArray( curRowArr, word, activeTextEffects );
			}
			else {
				//start next page
				buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
				buffer.push( [] );
				curPageIndex++;
				buffer[ curPageIndex ].push( [] );
				curRowIndex = 0;
				curRowArr = buffer[ curPageIndex ][ curRowIndex ];
				curRowArr = AddWordToCharArray( curRowArr, word, activeTextEffects );
			}
		}

		//destroy any empty stuff
		var lastPage = buffer[ buffer.length-1 ];
		var lastRow = lastPage[ lastPage.length-1 ];
		if( lastRow.length == 0 )
			lastPage.splice( lastPage.length-1, 1 );
		if( lastPage.length == 0 )
			buffer.splice( buffer.length-1, 1 );

		//finish up 
		lastPage = buffer[ buffer.length-1 ];
		lastRow = lastPage[ lastPage.length-1 ];
		if( lastRow.length > 0 ) {
			var lastChar = lastRow[ lastRow.length-1 ];
			lastChar.SetPrintHandler( onFinishHandler );
		}

		console.log(buffer);

		isActive = true;
	};

	this.AddLinebreak = function() {
		var lastPage = buffer[ buffer.length-1 ];
		if( lastPage.length <= 1 ) {
			console.log("LINEBREAK - NEW ROW ");
			// add new row
			lastPage.push( [] );
		}
		else {
			// add new page
			buffer.push( [[]] );
		}
		console.log(buffer);

		isActive = true;
	}

	/* new text effects */
	this.HasTextEffect = function(name) {
		return activeTextEffects.indexOf( name ) > -1;
	}
	this.AddTextEffect = function(name) {
		activeTextEffects.push( name );
	}
	this.RemoveTextEffect = function(name) {
		activeTextEffects.splice( activeTextEffects.indexOf( name ), 1 );
	}

	/* this is a hook for GIF rendering */
	var didPageFinishThisFrame = false;
	this.DidPageFinishThisFrame = function(){ return didPageFinishThisFrame; };

	var didFlipPageThisFrame = false;
	this.DidFlipPageThisFrame = function(){ return didFlipPageThisFrame; };

	// this.SetCharsPerRow = function(num){ charsPerRow = num; }; // hacky
};

/* ARABIC */
var ArabicHandler = function() {

	var arabicCharStart = 0x0621;
	var arabicCharEnd = 0x064E;

	var CharacterForm = {
		Isolated : 0,
		Final : 1,
		Initial : 2,
		Middle : 3
	};

	// map glyphs to their character forms
	var glyphForms = {
		/*		 Isolated, Final, Initial, Middle Forms	*/
		0x0621: [0xFE80,0xFE80,0xFE80,0xFE80], /*  HAMZA  */ 
		0x0622: [0xFE81,0xFE82,0xFE81,0xFE82], /*  ALEF WITH MADDA ABOVE  */ 
		0x0623: [0xFE83,0xFE84,0xFE83,0xFE84], /*  ALEF WITH HAMZA ABOVE  */ 
		0x0624: [0xFE85,0xFE86,0xFE85,0xFE86], /*  WAW WITH HAMZA ABOVE  */ 
		0x0625: [0xFE87,0xFE88,0xFE87,0xFE88], /*  ALEF WITH HAMZA BELOW  */ 
		0x0626: [0xFE89,0xFE8A,0xFE8B,0xFE8C], /*  YEH WITH HAMZA ABOVE  */ 
		0x0627: [0xFE8D,0xFE8E,0xFE8D,0xFE8E], /*  ALEF  */ 
		0x0628: [0xFE8F,0xFE90,0xFE91,0xFE92], /*  BEH  */ 
		0x0629: [0xFE93,0xFE94,0xFE93,0xFE94], /*  TEH MARBUTA  */ 
		0x062A: [0xFE95,0xFE96,0xFE97,0xFE98], /*  TEH  */ 
		0x062B: [0xFE99,0xFE9A,0xFE9B,0xFE9C], /*  THEH  */ 
		0x062C: [0xFE9D,0xFE9E,0xFE9F,0xFEA0], /*  JEEM  */ 
		0x062D: [0xFEA1,0xFEA2,0xFEA3,0xFEA4], /*  HAH  */ 
		0x062E: [0xFEA5,0xFEA6,0xFEA7,0xFEA8], /*  KHAH  */ 
		0x062F: [0xFEA9,0xFEAA,0xFEA9,0xFEAA], /*  DAL  */ 
		0x0630: [0xFEAB,0xFEAC,0xFEAB,0xFEAC], /*  THAL */ 
		0x0631: [0xFEAD,0xFEAE,0xFEAD,0xFEAE], /*  RAA  */ 
		0x0632: [0xFEAF,0xFEB0,0xFEAF,0xFEB0], /*  ZAIN  */ 
		0x0633: [0xFEB1,0xFEB2,0xFEB3,0xFEB4], /*  SEEN  */ 
		0x0634: [0xFEB5,0xFEB6,0xFEB7,0xFEB8], /*  SHEEN  */ 
		0x0635: [0xFEB9,0xFEBA,0xFEBB,0xFEBC], /*  SAD  */ 
		0x0636: [0xFEBD,0xFEBE,0xFEBF,0xFEC0], /*  DAD  */ 
		0x0637: [0xFEC1,0xFEC2,0xFEC3,0xFEC4], /*  TAH  */ 
		0x0638: [0xFEC5,0xFEC6,0xFEC7,0xFEC8], /*  ZAH  */ 
		0x0639: [0xFEC9,0xFECA,0xFECB,0xFECC], /*  AIN  */ 
		0x063A: [0xFECD,0xFECE,0xFECF,0xFED0], /*  GHAIN  */ 
		0x063B: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063C: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063D: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063E: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063F: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x0640: [0x0640,0x0640,0x0640,0x0640], /*  TATWEEL  */ 
		0x0641: [0xFED1,0xFED2,0xFED3,0xFED4], /*  FAA  */ 
		0x0642: [0xFED5,0xFED6,0xFED7,0xFED8], /*  QAF  */ 
		0x0643: [0xFED9,0xFEDA,0xFEDB,0xFEDC], /*  KAF  */ 
		0x0644: [0xFEDD,0xFEDE,0xFEDF,0xFEE0], /*  LAM  */ 
		0x0645: [0xFEE1,0xFEE2,0xFEE3,0xFEE4], /*  MEEM  */ 
		0x0646: [0xFEE5,0xFEE6,0xFEE7,0xFEE8], /*  NOON  */ 
		0x0647: [0xFEE9,0xFEEA,0xFEEB,0xFEEC], /*  HEH  */ 
		0x0648: [0xFEED,0xFEEE,0xFEED,0xFEEE], /*  WAW  */ 
		0x0649: [0xFEEF,0xFEF0,0xFBE8,0xFBE9], /*  ALEF MAKSURA  */ 
		0x064A: [0xFEF1,0xFEF2,0xFEF3,0xFEF4], /*  YEH  */ 
		0x064B: [0xFEF5,0xFEF6,0xFEF5,0xFEF6], /*  LAM ALEF MADD*/
		0x064C: [0xFEF7,0xFEF8,0xFEF7,0xFEF8], /*  LAM ALEF HAMZA ABOVE*/
		0x064D: [0xFEF9,0xFEFa,0xFEF9,0xFEFa], /*  LAM ALEF HAMZA BELOW*/
		0x064E: [0xFEFb,0xFEFc,0xFEFb,0xFEFc], /*  LAM ALEF */
	};

	var disconnectedCharacters = [0x0621,0x0622,0x0623,0x0624,0x0625,0x0627,0x062f,0x0630,0x0631,0x0632,0x0648,0x0649,0x064b,0x064c,0x064d,0x064e];

	function IsArabicCharacter(char) {
		var code = char.charCodeAt(0);
		return (code >= arabicCharStart && code <= arabicCharEnd);
	}

	function ContainsArabicCharacters(word) {
		for (var i = 0; i < word.length; i++) {
			if (IsArabicCharacter(word[i])) {
				return true;
			}
		}
		return false;
	}

	function IsDisconnectedCharacter(char) {
		var code = char.charCodeAt(0);
		return disconnectedCharacters.indexOf(code) != -1;
	}

	function ShapeArabicCharacters(word) {
		var shapedWord = "";

		for (var i = 0; i < word.length; i++) {
			if (!IsArabicCharacter(word[i])) {
				shapedWord += word[i];
				continue;
			}

			var connectedToPreviousChar = i-1 >= 0 && IsArabicCharacter(word[i-1]) && !IsDisconnectedCharacter(word[i-1]);

			var connectedToNextChar = i+1 < word.length && IsArabicCharacter(word[i+1]) && !IsDisconnectedCharacter(word[i]);

			var form;
			if (!connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Isolated;
			}
			else if (connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Final;
			}
			else if (!connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Initial;
			}
			else if (connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Middle;
			}

			var code = word[i].charCodeAt(0);

			// handle lam alef special case
			if (code == 0x0644 && connectedToNextChar) {
				var nextCode = word[i+1].charCodeAt(0);
				var specialCode = null;
				if (nextCode == 0x0622) {
					// alef madd
					specialCode = glyphForms[0x064b][form];
				}
				else if (nextCode == 0x0623) {
					// hamza above
					specialCode = glyphForms[0x064c][form];
				}
				else if (nextCode == 0x0625) {
					// hamza below
					specialCode = glyphForms[0x064d][form];
				}
				else if (nextCode == 0x0627) {
					// alef
					specialCode = glyphForms[0x064e][form];
				}

				if (specialCode != null) {
					shapedWord += String.fromCharCode(specialCode);
					i++; // skip a step
					continue;
				}
			}

			// hacky?
			if (form === CharacterForm.Isolated) {
				shapedWord += word[i];
				continue;
			}

			var shapedCode = glyphForms[code][form];
			shapedWord += String.fromCharCode(shapedCode);
		}

		return shapedWord;
	}

	this.ContainsArabicCharacters = ContainsArabicCharacters;
	this.ShapeArabicCharacters = ShapeArabicCharacters;
}

/* NEW TEXT EFFECTS */
var TextEffects = new Map();

var RainbowEffect = function() { // TODO - should it be an object or just a method?
	this.DoEffect = function(char,time) {
		// console.log("RAINBOW!!!");
		// console.log(char);
		// console.log(char.color);
		// console.log(char.col);

		var h = Math.abs( Math.sin( (time / 600) - (char.col / 8) ) );
		var rgb = hslToRgb( h, 1, 0.5 );
		char.color.r = rgb[0];
		char.color.g = rgb[1];
		char.color.b = rgb[2];
		char.color.a = 255;
	}
};
TextEffects["rbw"] = new RainbowEffect();

var ColorEffect = function(index) {
	this.DoEffect = function(char) {
		var pal = getPal( curPal() );
		var color = pal[ parseInt( index ) ];
		// console.log(color);
		char.color.r = color[0];
		char.color.g = color[1];
		char.color.b = color[2];
		char.color.a = 255;
	}
};
TextEffects["clr1"] = new ColorEffect(0);
TextEffects["clr2"] = new ColorEffect(1); // TODO : should I use parameters instead of special names?
TextEffects["clr3"] = new ColorEffect(2);

var WavyEffect = function() {
	this.DoEffect = function(char,time) {
		char.offset.y += Math.sin( (time / 250) - (char.col / 2) ) * 4;
	}
};
TextEffects["wvy"] = new WavyEffect();

var ShakyEffect = function() {
	function disturb(func,time,offset,mult1,mult2) {
		return func( (time * mult1) - (offset * mult2) );
	}

	this.DoEffect = function(char,time) {
		char.offset.y += 3
						* disturb(Math.sin,time,char.col,0.1,0.5)
						* disturb(Math.cos,time,char.col,0.3,0.2)
						* disturb(Math.sin,time,char.row,2.0,1.0);
		char.offset.x += 3
						* disturb(Math.cos,time,char.row,0.1,1.0)
						* disturb(Math.sin,time,char.col,3.0,0.7)
						* disturb(Math.cos,time,char.col,0.2,0.3);
	}
};
TextEffects["shk"] = new ShakyEffect();

} // Dialog()
</script>

<script>
/*
TODO
- reset renderer function
- react to changes in: drawings, palettes
- possible future plan: limit size of cache (remove old images)
- change image store path from (pal > col > draw) to (draw > pal > col)
- get rid of old getSpriteImage (etc) methods
- get editor working again [in progress]
- move debug timer class into core (seems useful)
*/

function Renderer(tilesize, scale) {

console.log("!!!!! NEW RENDERER");

var imageStore = { // TODO : rename to imageCache
	source: {},
	render: {}
};

var palettes = null; // TODO : need null checks?
var context = null;

function setPalettes(paletteObj) {
	palettes = paletteObj;

	// TODO : should this really clear out the render cache?
	imageStore.render = {};
}

function getPaletteColor(paletteId, colorIndex) {
	var palette = palettes[paletteId];

	if (colorIndex > palette.colors.length) { // do I need this failure case? (seems un-reliable)
		colorIndex = 0;
	}

	var color = palette.colors[colorIndex];

	return {
		r : color[0],
		g : color[1],
		b : color[2]
	};
}

var debugRenderCount = 0;

// TODO : change image store path from (pal > col > draw) to (draw > pal > col)
function renderImage(drawing, paletteId) {
	// debugRenderCount++;
	// console.log("RENDER COUNT " + debugRenderCount);

	var col = drawing.col;
	var colStr = "" + col;
	var pal = paletteId;
	var drwId = drawing.drw;
	var imgSrc = imageStore.source[ drawing.drw ];

	// initialize render cache entry
	if (imageStore.render[drwId] === undefined || imageStore.render[drwId] === null) {
		imageStore.render[drwId] = {};
	}

	if (imageStore.render[drwId][pal] === undefined || imageStore.render[drwId][pal] === null) {
		imageStore.render[drwId][pal] = {};
	}

	// create array of ImageData frames
	imageStore.render[drwId][pal][colStr] = [];

	for (var i = 0; i < imgSrc.length; i++) {
		var frameSrc = imgSrc[i];
		var frameData = imageDataFromImageSource( frameSrc, pal, col );
		imageStore.render[drwId][pal][colStr].push(frameData);
	}
}

function imageDataFromImageSource(imageSource, pal, col) {
	//console.log(imageSource);

	var img = context.createImageData(tilesize*scale,tilesize*scale);

	var backgroundColor = getPaletteColor(pal,0);
	var foregroundColor = getPaletteColor(pal,col);

	for (var y = 0; y < tilesize; y++) {
		for (var x = 0; x < tilesize; x++) {
			var px = imageSource[y][x];
			for (var sy = 0; sy < scale; sy++) {
				for (var sx = 0; sx < scale; sx++) {
					var pxl = (((y * scale) + sy) * tilesize * scale * 4) + (((x*scale) + sx) * 4);
					if ( px === 1 ) {
						img.data[pxl + 0] = foregroundColor.r;
						img.data[pxl + 1] = foregroundColor.g;
						img.data[pxl + 2] = foregroundColor.b;
						img.data[pxl + 3] = 255;
					}
					else { //ch === 0
						img.data[pxl + 0] = backgroundColor.r;
						img.data[pxl + 1] = backgroundColor.g;
						img.data[pxl + 2] = backgroundColor.b;
						img.data[pxl + 3] = 255;
					}
				}
			}
		}
	}

	return img;
}

// TODO : move into core
function undefinedOrNull(x) {
	return x === undefined || x === null;
}

function isImageRendered(drawing, paletteId) {
	var col = drawing.col;
	var colStr = "" + col;
	var pal = paletteId;
	var drwId = drawing.drw;

	if (undefinedOrNull(imageStore.render[drwId]) ||
		undefinedOrNull(imageStore.render[drwId][pal]) ||
		undefinedOrNull(imageStore.render[drwId][pal][colStr])) {
			return false;
	}
	else {
		return true;
	}
}

function getImageSet(drawing, paletteId) {
	return imageStore.render[drawing.drw][paletteId][drawing.col];
}

function getImageFrame(drawing, paletteId, frameOverride) {
	var frameIndex = 0;
	if (drawing.animation.isAnimated) {
		if (frameOverride != undefined && frameOverride != null) {
			frameIndex = frameOverride;
		}
		else {
			frameIndex = drawing.animation.frameIndex;
		}
	}

	return getImageSet(drawing, paletteId)[frameIndex];
}

function getOrRenderImage(drawing, paletteId, frameOverride) {
	if (!isImageRendered(drawing, paletteId)) {
		renderImage(drawing, paletteId);
	}

	return getImageFrame(drawing, paletteId, frameOverride);
}

/* PUBLIC INTERFACE */
this.GetImage = getOrRenderImage;

this.SetPalettes = setPalettes;

this.SetImageSource = function(drawingId, imageSourceData) {
	imageStore.source[drawingId] = imageSourceData;
	imageStore.render[drawingId] = {}; // reset render cache for this image
}

this.GetImageSource = function(drawingId) {
	return imageStore.source[drawingId];
}

this.GetFrameCount = function(drawingId) {
	return imageStore.source[drawingId].length;
}

this.AttachContext = function(ctx) {
	context = ctx;
}

} // Renderer()
</script>

<script>
var xhr; // TODO : remove
var canvas;
var context; // TODO : remove if safe?
var ctx;

var title = "";
var room = {};
var tile = {};
var sprite = {};
var item = {};
var dialog = {};
var palette = {
	"0" : [[0,0,0],[255,0,0],[255,255,255]] //start off with a default palette (can be overriden)
};
var ending = {};
var variable = {}; // these are starting variable values -- they don't update (or I don't think they will)
var playerId = "A";

var defaultFontName = "ascii_small";
var fontName = defaultFontName;
var TextDirection = {
	LeftToRight : "LTR",
	RightToLeft : "RTL"
};
var textDirection = TextDirection.LeftToRight;

var names = {
	room : new Map(),
	tile : new Map(), // Note: Not currently enabled in the UI
	sprite : new Map(),
	item : new Map(),
	/*dialog : new Map()*/ // TODO
	/*ending : new Map()*/ // TODO
};
function updateNamesFromCurData() {
	names.room = new Map();
	for(id in room) {
		if(room[id].name != undefined && room[id].name != null)
			names.room.set( room[id].name, id );
	}
	names.tile = new Map();
	for(id in tile) {
		if(tile[id].name != undefined && tile[id].name != null)
			names.tile.set( tile[id].name, id );
	}
	names.sprite = new Map();
	for(id in sprite) {
		if(sprite[id].name != undefined && sprite[id].name != null)
			names.sprite.set( sprite[id].name, id );
	}
	names.item = new Map();
	for(id in item) {
		if(item[id].name != undefined && item[id].name != null)
			names.item.set( item[id].name, id );
	}
}

var spriteStartLocations = {};

/* VERSION */
var version = {
	major: 5, // major changes
	minor: 5 // smaller changes
};
function getEngineVersion() {
	return version.major + "." + version.minor;
}

/* FLAGS */
var flags;
function resetFlags() {
	flags = {
		ROOM_FORMAT : 0 // 0 = non-comma separated, 1 = comma separated
	};
}
resetFlags(); //init flags on load script

// SUPER hacky location... :/
var editorDevFlags = {
	// NONE right now!
};

function clearGameData() {
	title = "";
	room = {};
	tile = {};
	sprite = {};
	item = {};
	dialog = {};
	palette = { //start off with a default palette (can be overriden)
		"0" : {
			name : null,
			colors : [[0,0,0],[255,0,0],[255,255,255]]
		}
	};
	ending = {};
	isEnding = false; //todo - correct place for this?
	variable = {};

	// TODO RENDERER : clear data?

	spriteStartLocations = {};

	names = {
		room : new Map(),
		tile : new Map(),
		sprite : new Map(),
		item : new Map()
	};

	fontName = defaultFontName; // TODO : reset font manager too?
	textDirection = TextDirection.LeftToRight;
}

var width = 128;
var height = 128;
var scale = 4; //this is stupid but necessary
var tilesize = 8;
var mapsize = 16;

var curRoom = "0";

var key = {
	left : 37,
	right : 39,
	up : 38,
	down : 40,
	space : 32,
	enter : 13,
	w : 87,
	a : 65,
	s : 83,
	d : 68,
	r : 82,
	shift : 16,
	ctrl : 17,
	alt : 18,
	cmd : 224
};

var prevTime = 0;
var deltaTime = 0;

//methods used to trigger gif recording
var didPlayerMoveThisFrame = false;
var onPlayerMoved = null;
// var didDialogUpdateThisFrame = false;
var onDialogUpdate = null;

//inventory update UI handles
var onInventoryChanged = null;
var onVariableChanged = null;

var isPlayerEmbeddedInEditor = false;

var renderer = new Renderer(tilesize, scale);

function getGameNameFromURL() {
	var game = window.location.hash.substring(1);
	// console.log("game name --- " + game);
	return game;
}

function attachCanvas(c) {
	canvas = c;
	canvas.width = width * scale;
	canvas.height = width * scale;
	ctx = canvas.getContext("2d");
	dialogRenderer.AttachContext(ctx);
	renderer.AttachContext(ctx);
}

var curGameData = null;
function load_game(game_data, startWithTitle) {
	curGameData = game_data; //remember the current game (used to reset the game)

	dialogBuffer.Reset();
	scriptInterpreter.ResetEnvironment(); // ensures variables are reset -- is this the best way?

	parseWorld(game_data);

	if (!isPlayerEmbeddedInEditor) {
		// hack to ensure default font is available
		fontManager.AddResource(defaultFontName + fontManager.GetExtension(), document.getElementById(defaultFontName).text.slice(1));
	}

	var font = fontManager.Get( fontName );
	dialogBuffer.SetFont(font);
	dialogRenderer.SetFont(font);

	setInitialVariables();

	// setInterval(updateLoadingScreen, 300); // hack test

	onready(startWithTitle);
}

function reset_cur_game() {
	if (curGameData == null) return; //can't reset if we don't have the game data
	stopGame();
	clearGameData();
	load_game(curGameData);
}

var update_interval = null;
function onready(startWithTitle) {
	if(startWithTitle === undefined || startWithTitle === null) startWithTitle = true;

	clearInterval(loading_interval);

	input = new InputManager();

	document.addEventListener('keydown', input.onkeydown);
	document.addEventListener('keyup', input.onkeyup);

	if (isPlayerEmbeddedInEditor) {
		canvas.addEventListener('touchstart', input.ontouchstart);
		canvas.addEventListener('touchmove', input.ontouchmove);
		canvas.addEventListener('touchend', input.ontouchend);
	}
	else {
		document.addEventListener('touchstart', input.ontouchstart);
		document.addEventListener('touchmove', input.ontouchmove);
		document.addEventListener('touchend', input.ontouchend);
	}

	window.onblur = input.onblur;

	update_interval = setInterval(update,-1);

	console.log("TITLE ??? " + startWithTitle);
	if(startWithTitle) // used by editor
		startNarrating(title);
}

function setInitialVariables() {
	for(id in variable) {
		var value = variable[id]; // default to string
		if(value === "true") {
			value = true;
		}
		else if(value === "false") {
			value = false;
		}
		else if(!isNaN(parseFloat(value))) {
			value = parseFloat(value);
		}
		scriptInterpreter.SetVariable(id,value);
	}
	scriptInterpreter.SetOnVariableChangeHandler( onVariableChanged );
}

// TODO: this is likely broken
function breadthFirstSearch(map, from, to) {
	from.trail = [];
	var visited = [];
	var queue = [from];
	visited.push( posToString(from) );

	//console.log( "~ bfs ~");
	//console.log( posToString(from) + " to " + posToString(to) );

	while ( queue.length > 0 ) {

		//grab pos from queue and mark as visited
		var curPos = queue.shift();

		//console.log( posToString(curPos) );
		//console.log( ".. " + pathToString(curPos.trail) );
		//console.log( visited );

		if (curPos.x == to.x && curPos.y == to.y) {
			//found a path!
			var path = curPos.trail.splice(0);
			path.push( curPos );
			return path;
		}

		//look at neighbors
		neighbors(curPos).forEach( function(n) {
			var inBounds = (n.x >= 0 && n.x < 16 && n.y >= 0 && n.y < 16);
			if (inBounds) {
				var noCollision = map[n.y][n.x] <= 0;
				var notVisited = visited.indexOf( posToString(n) ) == -1;
				if (noCollision && notVisited) {
					n.trail = curPos.trail.slice();
					n.trail.push(curPos);
					queue.push( n );
					visited.push( posToString(n) );
				}
			}
		});

	}

	return []; // no path found
}

function posToString(pos) {
	return pos.x + "," + pos.y;
}

function pathToString(path) {
	var s = "";
	for (i in path) {
		s += posToString(path[i]) + " ";
	}
	return s;
}

function neighbors(pos) {
	var neighborList = [];
	neighborList.push( {x:pos.x+1, y:pos.y+0} );
	neighborList.push( {x:pos.x-1, y:pos.y+0} );
	neighborList.push( {x:pos.x+0, y:pos.y+1} );
	neighborList.push( {x:pos.x+0, y:pos.y-1} );
	return neighborList;
}

function collisionMap(roomId) {
	var map = [
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
	];

	for (r in room[roomId].tilemap) {
		var row = room[roomId].tilemap[r];
		for (var c = 0; c < row.length; c++) {
			if (room[roomId].walls.indexOf( row[x] ) != -1) {
				map[r][c] = 1;
			}
		}
	}

	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === roomId) {
			map[spr.y][spr.x] = 2;
		}
	}

	return map;
}

function getOffset(evt) {
	var offset = { x:0, y:0 };

	var el = evt.target;
	var rect = el.getBoundingClientRect();

	offset.x += rect.left + el.scrollLeft;
	offset.y += rect.top + el.scrollTop;

	offset.x = evt.clientX - offset.x;
	offset.y = evt.clientY - offset.y;

	return offset;
}

function stopGame() {
	console.log("stop GAME!");

	document.removeEventListener('keydown', input.onkeydown);
	document.removeEventListener('keyup', input.onkeyup);

	if (isPlayerEmbeddedInEditor) {
		canvas.removeEventListener('touchstart', input.ontouchstart);
		canvas.removeEventListener('touchmove', input.ontouchmove);
		canvas.removeEventListener('touchend', input.ontouchend);
	}
	else {
		document.removeEventListener('touchstart', input.ontouchstart);
		document.removeEventListener('touchmove', input.ontouchmove);
		document.removeEventListener('touchend', input.ontouchend);
	}

	window.onblur = null;

	clearInterval(update_interval);
}

/* loading animation */
var loading_anim_data = [
	[
		0,1,1,1,1,1,1,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,0,0,0,0,0,0,0,
		1,0,0,0,0,0,0,1,
		1,1,1,0,0,1,1,1,
		1,1,1,1,1,0,0,1,
		1,1,1,1,1,0,0,1,
		1,1,1,0,0,1,1,1,
		1,0,0,0,0,0,0,1,
		0,0,0,0,0,0,0,0,
	]
];
var loading_anim_frame = 0;
var loading_anim_speed = 500;
var loading_interval = null;

function loadingAnimation() {
	//create image
	var loadingAnimImg = ctx.createImageData(8*scale, 8*scale);
	//draw image
	for (var y = 0; y < 8; y++) {
		for (var x = 0; x < 8; x++) {
			var i = (y * 8) + x;
			if (loading_anim_data[loading_anim_frame][i] == 1) {
				//scaling nonsense
				for (var sy = 0; sy < scale; sy++) {
					for (var sx = 0; sx < scale; sx++) {
						var pxl = 4 * ( (((y*scale)+sy) * (8*scale)) + ((x*scale)+sx) );
						loadingAnimImg.data[pxl+0] = 255;
						loadingAnimImg.data[pxl+1] = 255;
						loadingAnimImg.data[pxl+2] = 255;
						loadingAnimImg.data[pxl+3] = 255;
					}
				}
			}
		}
	}
	//put image on canvas
	ctx.putImageData(loadingAnimImg,scale*(width/2 - 4),scale*(height/2 - 4));
	//update frame
	loading_anim_frame++;
	if (loading_anim_frame >= 5) loading_anim_frame = 0;
}

function updateLoadingScreen() {
	// TODO : in progress
	ctx.fillStyle = "rgb(0,0,0)";
	ctx.fillRect(0,0,canvas.width,canvas.height);

	loadingAnimation();
	drawSprite( getSpriteImage(sprite["a"],"0",0), 8, 8, ctx );
}

function update() {
	var curTime = Date.now();
	deltaTime = curTime - prevTime;

	updateInput();

	if (!isNarrating && !isEnding) {
		updateAnimation();
		drawRoom( room[curRoom] ); // draw world if game has begun
	}
	else {
		//make sure to still clear screen
		ctx.fillStyle = "rgb(" + getPal(curPal())[0][0] + "," + getPal(curPal())[0][1] + "," + getPal(curPal())[0][2] + ")";
		ctx.fillRect(0,0,canvas.width,canvas.height);
	}

	// if (isDialogMode) { // dialog mode
	if(dialogBuffer.IsActive()) {
		dialogRenderer.Draw( dialogBuffer, deltaTime );
		dialogBuffer.Update( deltaTime );
	}
	else if (!isEnding) {
		moveSprites();
	}

	// keep moving avatar if player holds down button
	if( !dialogBuffer.IsActive() && !isEnding )
	{
		if( curPlayerDirection != Direction.None ) {
			playerHoldToMoveTimer -= deltaTime;

			if( playerHoldToMoveTimer <= 0 )
			{
				movePlayer( curPlayerDirection );
				playerHoldToMoveTimer = 150;
			}
		}
	}

	prevTime = curTime;

	//for gif recording
	if (didPlayerMoveThisFrame && onPlayerMoved != null) onPlayerMoved();
	didPlayerMoveThisFrame = false;
	// if (didDialogUpdateThisFrame && onDialogUpdate != null) onDialogUpdate();
	// didDialogUpdateThisFrame = false;
	/* hacky replacement */
	if (onDialogUpdate != null)
		dialogRenderer.SetPageFinishHandler( onDialogUpdate );

	input.resetKeyPressed();
	input.resetTapReleased();
}

function updateInput() {
	if( dialogBuffer.IsActive() ) {
		if (input.anyKeyPressed() || input.isTapReleased()) {
			/* CONTINUE DIALOG */
			if (dialogBuffer.CanContinue()) {
				var hasMoreDialog = dialogBuffer.Continue();
				if(!hasMoreDialog) {
					// ignore currently held keys UNTIL they are released (stops player from insta-moving)
					input.ignoreHeldKeys();

					onExitDialog();
				}
			}
			else {
				dialogBuffer.Skip();
			}
		}
	}
	else if ( isEnding ) {
		if (input.anyKeyPressed() || input.isTapReleased()) {
			/* RESTART GAME */
			reset_cur_game();
		}
	}
	else {
		/* WALK */
		var prevPlayerDirection = curPlayerDirection;

		if ( input.isKeyDown( key.left ) || input.isKeyDown( key.a ) || input.swipeLeft() ) {
			curPlayerDirection = Direction.Left;
		}
		else if ( input.isKeyDown( key.right ) || input.isKeyDown( key.d ) || input.swipeRight() ) {
			curPlayerDirection = Direction.Right;
		}
		else if ( input.isKeyDown( key.up ) || input.isKeyDown( key.w ) || input.swipeUp() ) {
			curPlayerDirection = Direction.Up;
		}
		else if ( input.isKeyDown( key.down ) || input.isKeyDown( key.s ) || input.swipeDown() ) {
			curPlayerDirection = Direction.Down;
		}
		else {
			curPlayerDirection = Direction.None;
		}

		if (curPlayerDirection != Direction.None && curPlayerDirection != prevPlayerDirection) {
			movePlayer( curPlayerDirection );
			playerHoldToMoveTimer = 500;
		}
	}
}

var animationCounter = 0;
var animationTime = 400;
function updateAnimation() {
	animationCounter += deltaTime;

	if ( animationCounter >= animationTime ) {

		// animate sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.animation.isAnimated) {
				spr.animation.frameIndex = ( spr.animation.frameIndex + 1 ) % spr.animation.frameCount;
			}
		}

		// animate tiles
		for (id in tile) {
			var til = tile[id];
			if (til.animation.isAnimated) {
				til.animation.frameIndex = ( til.animation.frameIndex + 1 ) % til.animation.frameCount;
			}
		}

		// animate items
		for (id in item) {
			var itm = item[id];
			if (itm.animation.isAnimated) {
				itm.animation.frameIndex = ( itm.animation.frameIndex + 1 ) % itm.animation.frameCount;
			}
		}

		// reset counter
		animationCounter = 0;

	}
}

var moveCounter = 0;
var moveTime = 200;
function moveSprites() {
	moveCounter += deltaTime;

	if (moveCounter >= moveTime) {

		for (id in sprite) {
			var spr = sprite[id];
			if (spr.walkingPath.length > 0) {
				//move sprite
				var nextPos = spr.walkingPath.shift();
				spr.x = nextPos.x;
				spr.y = nextPos.y;


				var end = getEnding( spr.room, spr.x, spr.y );
				var ext = getExit( spr.room, spr.x, spr.y );
				var itmIndex = getItemIndex( spr.room, spr.x, spr.y );
				if (end) { //if the sprite hits an ending
					if (id === playerId) { // only the player can end the game
						startNarrating( ending[end.id], true /*isEnding*/ );
					}
				}
				else if (ext) { //if the sprite hits an exit
					//move it to another scene
					spr.room = ext.dest.room;
					spr.x = ext.dest.x;
					spr.y = ext.dest.y;
					if (id === playerId) {
						//if the player changes scenes, change the visible scene
						curRoom = ext.dest.room;
					}
				}
				else if(itmIndex > -1) {
					var itm = room[ spr.room ].items[ itmIndex ];
					room[ spr.room ].items.splice( itmIndex, 1 );
					if( spr.inventory[ itm.id ] )
						spr.inventory[ itm.id ] += 1;
					else
						spr.inventory[ itm.id ] = 1;

					if(onInventoryChanged != null)
						onInventoryChanged( itm.id );

					if(id === playerId)
						startItemDialog( itm.id  /*itemId*/ );

					// stop moving : is this a good idea?
					spr.walkingPath = [];
				}

				if (id === playerId) didPlayerMoveThisFrame = true;
			}
		}

		moveCounter = 0;
	}

}

function getSpriteAt(x,y) {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === curRoom) {
			if (spr.x == x && spr.y == y) {
				return id;
			}
		}
	}
	return null;
}

var Direction = {
	None : -1,
	Up : 0,
	Down : 1,
	Left : 2,
	Right : 3
};

var curPlayerDirection = Direction.None;
var playerHoldToMoveTimer = 0;

var InputManager = function() {
	var self = this;

	var pressed;
	var ignored;
	var newKeyPress;
	var touchState;

	function resetAll() {
		pressed = {};
		ignored = {};
		newKeyPress = false;

		touchState = {
			isDown : false,
			startX : 0,
			startY : 0,
			curX : 0,
			curY : 0,
			swipeDistance : 30,
			swipeDirection : Direction.None,
			tapReleased : false
		};
	}
	resetAll();

	function stopWindowScrolling(e) {
		if(e.keyCode == key.left || e.keyCode == key.right || e.keyCode == key.up || e.keyCode == key.down || !isPlayerEmbeddedInEditor)
			e.preventDefault();
	}

	function tryRestartGame(e) {
		/* RESTART GAME */
		if ( e.keyCode === key.r && ( e.getModifierState("Control") || e.getModifierState("Meta") ) ) {
			if ( confirm("Restart the game?") ) {
				reset_cur_game();
			}
		}
	}

	function eventIsModifier(event) {
		return (event.keyCode == key.shift || event.keyCode == key.ctrl || event.keyCode == key.alt || event.keyCode == key.cmd);
	}

	function isModifierKeyDown() {
		return ( self.isKeyDown(key.shift) || self.isKeyDown(key.ctrl) || self.isKeyDown(key.alt) || self.isKeyDown(key.cmd) );
	}

	this.ignoreHeldKeys = function() {
		for (var key in pressed) {
			if (pressed[key]) { // only ignore keys that are actually held
				ignored[key] = true;
				// console.log("IGNORE -- " + key);
			}
		}
	}

	this.onkeydown = function(event) {
		// console.log("KEYDOWN -- " + event.keyCode);

		stopWindowScrolling(event);

		tryRestartGame(event);

		// Special keys being held down can interfere with keyup events and lock movement
		// so just don't collect input when they're held
		{
			if (isModifierKeyDown()) {
				return;
			}

			if (eventIsModifier(event)) {
				resetAll();
			}
		}

		if (ignored[event.keyCode]) {
			return;
		}

		if (!self.isKeyDown(event.keyCode)) {
			newKeyPress = true;
		}

		pressed[event.keyCode] = true;
		ignored[event.keyCode] = false;
	}

	this.onkeyup = function(event) {
		// console.log("KEYUP -- " + event.keyCode);
		pressed[event.keyCode] = false;
		ignored[event.keyCode] = false;
	}

	this.ontouchstart = function(event) {
		event.preventDefault();

		if( event.changedTouches.length > 0 ) {
			touchState.isDown = true;

			touchState.startX = touchState.curX = event.changedTouches[0].clientX;
			touchState.startY = touchState.curY = event.changedTouches[0].clientY;

			touchState.swipeDirection = Direction.None;
		}
	}

	this.ontouchmove = function(event) {
		event.preventDefault();

		if( touchState.isDown && event.changedTouches.length > 0 ) {
			touchState.curX = event.changedTouches[0].clientX;
			touchState.curY = event.changedTouches[0].clientY;

			var prevDirection = touchState.swipeDirection;

			if( touchState.curX - touchState.startX <= -touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Left;
			}
			else if( touchState.curX - touchState.startX >= touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Right;
			}
			else if( touchState.curY - touchState.startY <= -touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Up;
			}
			else if( touchState.curY - touchState.startY >= touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Down;
			}

			if( touchState.swipeDirection != prevDirection ) {
				// reset center so changing directions is easier
				touchState.startX = touchState.curX;
				touchState.startY = touchState.curY;
			}
		}
	}

	this.ontouchend = function(event) {
		event.preventDefault();

		touchState.isDown = false;

		if( touchState.swipeDirection == Direction.None ) {
			// tap!
			touchState.tapReleased = true;
		}

		touchState.swipeDirection = Direction.None;
	}

	this.isKeyDown = function(keyCode) {
		return pressed[keyCode] != null && pressed[keyCode] == true && (ignored[keyCode] == null || ignored[keyCode] == false);
	}

	this.anyKeyPressed = function() {
		return newKeyPress;
	}

	this.resetKeyPressed = function() {
		newKeyPress = false;
	}

	this.swipeLeft = function() {
		return touchState.swipeDirection == Direction.Left;
	}

	this.swipeRight = function() {
		return touchState.swipeDirection == Direction.Right;
	}

	this.swipeUp = function() {
		return touchState.swipeDirection == Direction.Up;
	}

	this.swipeDown = function() {
		return touchState.swipeDirection == Direction.Down;
	}

	this.isTapReleased = function() {
		return touchState.tapReleased;
	}

	this.resetTapReleased = function() {
		touchState.tapReleased = false;
	}

	this.onblur = function() {
		// console.log("~~~ BLUR ~~");
		resetAll();
	}
}
var input = null;

function movePlayer(direction) {
	var spr = null;

	if ( curPlayerDirection == Direction.Left && !(spr = getSpriteLeft()) && !isWallLeft()) {
		player().x -= 1;
		didPlayerMoveThisFrame = true;
	}
	else if ( curPlayerDirection == Direction.Right && !(spr = getSpriteRight()) && !isWallRight()) {
		player().x += 1;
		didPlayerMoveThisFrame = true;
	}
	else if ( curPlayerDirection == Direction.Up && !(spr = getSpriteUp()) && !isWallUp()) {
		player().y -= 1;
		didPlayerMoveThisFrame = true;
	}
	else if ( curPlayerDirection == Direction.Down && !(spr = getSpriteDown()) && !isWallDown()) {
		player().y += 1;
		didPlayerMoveThisFrame = true;
	}
	
	var ext = getExit( player().room, player().x, player().y );
	var end = getEnding( player().room, player().x, player().y );
	var itmIndex = getItemIndex( player().room, player().x, player().y );

	// do items first, because you can pick up an item AND go through a door
	if (itmIndex > -1) {
		// TODO pick up items (what about touch?)
		// console.log("HIT ITM ");
		// console.log( itmIndex );
		var itm = room[ player().room ].items[ itmIndex ];
		// console.log(itm);
		room[ player().room ].items.splice( itmIndex, 1 );
		if( player().inventory[ itm.id ] )
			player().inventory[ itm.id ] += 1;
		else
			player().inventory[ itm.id ] = 1;

		if(onInventoryChanged != null)
			onInventoryChanged( itm.id );

		startItemDialog( itm.id  /*itemId*/ );

		// console.log( player().inventory );
	}

	if (end) {
		startNarrating( ending[end.id], true /*isEnding*/ );
	}
	else if (ext) {
		player().room = ext.dest.room;
		player().x = ext.dest.x;
		player().y = ext.dest.y;
		curRoom = ext.dest.room;
	}
	else if (spr) {
		startSpriteDialog( spr /*spriteId*/ );
	}
}

function getItemIndex( roomId, x, y ) {
	for( var i = 0; i < room[roomId].items.length; i++ ) {
		var itm = room[roomId].items[i];
		if ( itm.x == x && itm.y == y)
			return i;
	}
	return -1;
}

function getSpriteLeft() { //repetitive?
	return getSpriteAt( player().x - 1, player().y );
}

function getSpriteRight() {
	return getSpriteAt( player().x + 1, player().y );
}

function getSpriteUp() {
	return getSpriteAt( player().x, player().y - 1 );
}

function getSpriteDown() {
	return getSpriteAt( player().x, player().y + 1 );
}

function isWallLeft() {
	return (player().x - 1 < 0) || isWall( player().x - 1, player().y );
}

function isWallRight() {
	return (player().x + 1 >= 16) || isWall( player().x + 1, player().y );
}

function isWallUp() {
	return (player().y - 1 < 0) || isWall( player().x, player().y - 1 );
}

function isWallDown() {
	return (player().y + 1 >= 16) || isWall( player().x, player().y + 1 );
}

function isWall(x,y,roomId) {
	if(roomId == undefined || roomId == null)
		roomId = curRoom;

	var tileId = getTile( x, y );

	if( tileId === '0' )
		return false; // Blank spaces aren't walls, ya doofus

	if( tile[tileId].isWall === undefined || tile[tileId].isWall === null ) {
		// No wall-state defined: check room-specific walls
		var i = room[roomId].walls.indexOf( getTile(x,y) );
		return i > -1;
	}

	// Otherwise, use the tile's own wall-state
	return tile[tileId].isWall;
}

function getItem(roomId,x,y) {
	for (i in room[roomId].items) {
		var item = room[roomId].items[i];
		if (x == item.x && y == item.y) {
			return item;
		}
	}
	return null;
}

function getExit(roomId,x,y) {
	for (i in room[roomId].exits) {
		var e = room[roomId].exits[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getEnding(roomId,x,y) {
	for (i in room[roomId].endings) {
		var e = room[roomId].endings[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getTile(x,y) {
	// console.log(x + " " + y);
	var t = getRoom().tilemap[y][x];
	return t;
}

function player() {
	return sprite[playerId];
}

// Sort of a hack for legacy palette code (when it was just an array)
function getPal(id) {
	return palette[ id ].colors;
}

function getRoom() {
	return room[curRoom];
}

function isSpriteOffstage(id) {
	return sprite[id].room == null;
}

function parseWorld(file) {
	// console.log("~~~ PARSE WORLD ~~~");
	// console.log(file);

	// var parseTimer = new Timer();

	resetFlags();

	var versionNumber = 0;

	var lines = file.split("\n");
	var i = 0;
	while (i < lines.length) {
		var curLine = lines[i];

		// console.log(lines[i]);

		if (i == 0) {
			i = parseTitle(lines, i);
		}
		else if (curLine.length <= 0 || curLine.charAt(0) === "#") {
			// collect version number (from a comment.. hacky I know)
			if (curLine.indexOf("# BITSY VERSION ") != -1) {
				versionNumber = parseFloat(curLine.replace("# BITSY VERSION ", ""));
			}

			//skip blank lines & comments
			i++;
		}
		else if (getType(curLine) == "PAL") {
			i = parsePalette(lines, i);
		}
		else if (getType(curLine) === "ROOM" || getType(curLine) === "SET") { //SET for back compat
			i = parseRoom(lines, i);
		}
		else if (getType(curLine) === "TIL") {
			i = parseTile(lines, i);
		}
		else if (getType(curLine) === "SPR") {
			i = parseSprite(lines, i);
		}
		else if (getType(curLine) === "ITM") {
			i = parseItem(lines, i);
		}
		else if (getType(curLine) === "DRW") {
			i = parseDrawing(lines, i);
		}
		else if (getType(curLine) === "DLG") {
			i = parseDialog(lines, i);
		}
		else if (getType(curLine) === "END") {
			i = parseEnding(lines, i);
		}
		else if (getType(curLine) === "VAR") {
			i = parseVariable(lines, i);
		}
		else if (getType(curLine) === "DEFAULT_FONT") {
			i = parseFontName(lines, i);
		}
		else if (getType(curLine) === "TEXT_DIRECTION") {
			i = parseTextDirection(lines, i);
		}
		else if (getType(curLine) === "FONT") {
			i = parseFontData(lines, i);
		}
		else if (getType(curLine) === "!") {
			i = parseFlag(lines, i);
		}
		else {
			i++;
		}
	}
	placeSprites();
	if (player().room != null) {
		curRoom = player().room;
	}

	renderer.SetPalettes(palette);

	// console.log(names);

	// console.log("~~~~~ PARSE TIME " + parseTimer.Milliseconds());

	return versionNumber;
}

//TODO this is in progress and doesn't support all features
function serializeWorld(skipFonts) {
	if (skipFonts === undefined || skipFonts === null)
		skipFonts = false;

	var worldStr = "";
	/* TITLE */
	worldStr += title + "\n";
	worldStr += "\n";
	/* VERSION */
	worldStr += "# BITSY VERSION " + getEngineVersion() + "\n"; // add version as a comment for debugging purposes
	worldStr += "\n";
	/* FLAGS */
	for (f in flags) {
		worldStr += "! " + f + " " + flags[f] + "\n";
	}
	worldStr += "\n"
	/* FONT */
	if (fontName != defaultFontName) {
		worldStr += "DEFAULT_FONT " + fontName + "\n";
		worldStr += "\n"
	}
	if (textDirection != TextDirection.LeftToRight) {
		worldStr += "TEXT_DIRECTION " + textDirection + "\n";
		worldStr += "\n"
	}
	/* PALETTE */
	for (id in palette) {
		worldStr += "PAL " + id + "\n";
		if( palette[id].name != null )
			worldStr += "NAME " + palette[id].name + "\n";
		for (i in getPal(id)) {
			for (j in getPal(id)[i]) {
				worldStr += getPal(id)[i][j];
				if (j < 2) worldStr += ",";
			}
			worldStr += "\n";
		}
		worldStr += "\n";
	}
	/* ROOM */
	for (id in room) {
		worldStr += "ROOM " + id + "\n";
		if ( flags.ROOM_FORMAT == 0 ) {
			// old non-comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];	
				}
				worldStr += "\n";
			}
		}
		else if ( flags.ROOM_FORMAT == 1 ) {
			// new comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];
					if (j < room[id].tilemap[i].length-1) worldStr += ","
				}
				worldStr += "\n";
			}
		}
		if (room[id].name != null) {
			/* NAME */
			worldStr += "NAME " + room[id].name + "\n";
		}
		if (room[id].walls.length > 0) {
			/* WALLS */
			worldStr += "WAL ";
			for (j in room[id].walls) {
				worldStr += room[id].walls[j];
				if (j < room[id].walls.length-1) {
					worldStr += ",";
				}
			}
			worldStr += "\n";
		}
		if (room[id].items.length > 0) {
			/* ITEMS */
			for (j in room[id].items) {
				var itm = room[id].items[j];
				worldStr += "ITM " + itm.id + " " + itm.x + "," + itm.y;
				worldStr += "\n";
			}
		}
		if (room[id].exits.length > 0) {
			/* EXITS */
			for (j in room[id].exits) {
				var e = room[id].exits[j];
				if ( isExitValid(e) ) {
					worldStr += "EXT " + e.x + "," + e.y + " " + e.dest.room + " " + e.dest.x + "," + e.dest.y;
					worldStr += "\n";
				}
			}
		}
		if (room[id].endings.length > 0) {
			/* ENDINGS */
			for (j in room[id].endings) {
				var e = room[id].endings[j];
				// todo isEndingValid
				worldStr += "END " + e.id + " " + e.x + "," + e.y;
				worldStr += "\n";
			}
		}
		if (room[id].pal != null) {
			/* PALETTE */
			worldStr += "PAL " + room[id].pal + "\n";
		}
		worldStr += "\n";
	}
	/* TILES */
	for (id in tile) {
		worldStr += "TIL " + id + "\n";
		worldStr += serializeDrawing( "TIL_" + id );
		if (tile[id].name != null && tile[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + tile[id].name + "\n";
		}
		if (tile[id].isWall != null && tile[id].isWall != undefined) {
			/* WALL */
			worldStr += "WAL " + tile[id].isWall + "\n";
		}
		if (tile[id].col != null && tile[id].col != undefined && tile[id].col != 1) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + tile[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* SPRITES */
	for (id in sprite) {
		worldStr += "SPR " + id + "\n";
		worldStr += serializeDrawing( "SPR_" + id );
		if (sprite[id].name != null && sprite[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + sprite[id].name + "\n";
		}
		if (sprite[id].dlg != null) {
			worldStr += "DLG " + sprite[id].dlg + "\n";
		}
		if (sprite[id].room != null) {
			/* SPRITE POSITION */
			worldStr += "POS " + sprite[id].room + " " + sprite[id].x + "," + sprite[id].y + "\n";
		}
		if (sprite[id].inventory != null) {
			for(itemId in sprite[id].inventory) {
				worldStr += "ITM " + itemId + " " + sprite[id].inventory[itemId] + "\n";
			}
		}
		if (sprite[id].col != null && sprite[id].col != undefined && sprite[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + sprite[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* ITEMS */
	for (id in item) {
		worldStr += "ITM " + id + "\n";
		worldStr += serializeDrawing( "ITM_" + id );
		if (item[id].name != null && item[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + item[id].name + "\n";
		}
		if (item[id].dlg != null) {
			worldStr += "DLG " + item[id].dlg + "\n";
		}
		if (item[id].col != null && item[id].col != undefined && item[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + item[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* DIALOG */
	for (id in dialog) {
		worldStr += "DLG " + id + "\n";
		worldStr += dialog[id] + "\n";
		worldStr += "\n";
	}
	/* ENDINGS */
	for (id in ending) {
		worldStr += "END " + id + "\n";
		worldStr += ending[id] + "\n";
		worldStr += "\n";
	}
	/* VARIABLES */
	for (id in variable) {
		worldStr += "VAR " + id + "\n";
		worldStr += variable[id] + "\n";
		worldStr += "\n";
	}
	/* FONT */
	// TODO : support multiple fonts
	if (fontName != defaultFontName && !skipFonts) {
		worldStr += fontManager.GetData(fontName);
	}

	return worldStr;
}

function serializeDrawing(drwId) {
	var imageSource = renderer.GetImageSource(drwId);
	var drwStr = "";
	for (f in imageSource) {
		for (y in imageSource[f]) {
			var rowStr = "";
			for (x in imageSource[f][y]) {
				rowStr += imageSource[f][y][x];
			}
			drwStr += rowStr + "\n";
		}
		if (f < (imageSource.length-1)) drwStr += ">\n";
	}
	return drwStr;
}

function isExitValid(e) {
	var hasValidStartPos = e.x >= 0 && e.x < 16 && e.y >= 0 && e.y < 16;
	var hasDest = e.dest != null;
	var hasValidRoomDest = (e.dest.room != null && e.dest.x >= 0 && e.dest.x < 16 && e.dest.y >= 0 && e.dest.y < 16);
	return hasValidStartPos && hasDest && hasValidRoomDest;
}

function placeSprites() {
	for (id in spriteStartLocations) {
		//console.log(id);
		//console.log( spriteStartLocations[id] );
		//console.log(sprite[id]);
		sprite[id].room = spriteStartLocations[id].room;
		sprite[id].x = spriteStartLocations[id].x;
		sprite[id].y = spriteStartLocations[id].y;
		//console.log(sprite[id]);
	}
}

/* ARGUMENT GETTERS */
function getType(line) {
	return getArg(line,0);
}

function getId(line) {
	return getArg(line,1);
}

function getArg(line,arg) {
	return line.split(" ")[arg];
}

function getCoord(line,arg) {
	return getArg(line,arg).split(",");
}

function parseTitle(lines, i) {
	title = lines[i];
	i++;
	return i;
}

function parseRoom(lines, i) {
	var id = getId(lines[i]);
	room[id] = {
		id : id,
		tilemap : [],
		walls : [],
		exits : [],
		endings : [],
		items : [],
		pal : null,
		name : null
	};
	i++;

	// create tile map
	if ( flags.ROOM_FORMAT == 0 ) {
		// old way: no commas, single char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lines[i].charAt(x) );
			}
			y++;
		}
	}
	else if ( flags.ROOM_FORMAT == 1 ) {
		// new way: comma separated, multiple char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			var lineSep = lines[i].split(",");
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lineSep[x] );
			}
			y++;
		}
	}

	while (i < lines.length && lines[i].length > 0) { //look for empty line
		// console.log(getType(lines[i]));
		if (getType(lines[i]) === "SPR") {
			/* NOTE SPRITE START LOCATIONS */
			var sprId = getId(lines[i]);
			if (sprId.indexOf(",") == -1 && lines[i].split(" ").length >= 3) { //second conditional checks for coords
				/* PLACE A SINGLE SPRITE */
				var sprCoord = lines[i].split(" ")[2].split(",");
				spriteStartLocations[sprId] = {
					room : id,
					x : parseInt(sprCoord[0]),
					y : parseInt(sprCoord[1])
				};
			}
			else if ( flags.ROOM_FORMAT == 0 ) { // TODO: right now this shortcut only works w/ the old comma separate format
				/* PLACE MULTIPLE SPRITES*/ 
				//Does find and replace in the tilemap (may be hacky, but its convenient)
				var sprList = sprId.split(",");
				for (row in room[id].tilemap) {
					for (s in sprList) {
						var col = room[id].tilemap[row].indexOf( sprList[s] );
						//if the sprite is in this row, replace it with the "null tile" and set its starting position
						if (col != -1) {
							room[id].tilemap[row][col] = "0";
							spriteStartLocations[ sprList[s] ] = {
								room : id,
								x : parseInt(col),
								y : parseInt(row)
							};
						}
					}
				}
			}
		}
		else if (getType(lines[i]) === "ITM") {
			var itmId = getId(lines[i]);
			var itmCoord = lines[i].split(" ")[2].split(",");
			var itm = {
				id: itmId,
				x : parseInt(itmCoord[0]),
				y : parseInt(itmCoord[1])
			};
			room[id].items.push( itm );
		}
		else if (getType(lines[i]) === "WAL") {
			/* DEFINE COLLISIONS (WALLS) */
			room[id].walls = getId(lines[i]).split(",");
		}
		else if (getType(lines[i]) === "EXT") {
			/* ADD EXIT */
			var exitArgs = lines[i].split(" ");
			//arg format: EXT 10,5 M 3,2 [AVA:7 LCK:a,9] [AVA 7 LCK a 9]
			var exitCoords = exitArgs[1].split(",");
			var destName = exitArgs[2];
			var destCoords = exitArgs[3].split(",");
			var ext = {
				x : parseInt(exitCoords[0]),
				y : parseInt(exitCoords[1]),
				dest : {
					room : destName,
					x : parseInt(destCoords[0]),
					y : parseInt(destCoords[1])
				}
			};
			room[id].exits.push(ext);
		}
		else if (getType(lines[i]) === "END") {
			/* ADD ENDING */
			var endId = getId( lines[i] );
			var endCoords = getCoord( lines[i], 2 );
			var end = {
				id : endId,
				x : parseInt( endCoords[0] ),
				y : parseInt( endCoords[1] )
			};
			room[id].endings.push(end);
		}
		else if (getType(lines[i]) === "PAL") {
			/* CHOOSE PALETTE (that's not default) */
			room[id].pal = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			var name = lines[i].split(/\s(.+)/)[1];
			room[id].name = name;
			names.room.set( name, id);
		}
		i++;
	}
	return i;
}

function parsePalette(lines,i) { //todo this has to go first right now :(
	var id = getId(lines[i]);
	i++;
	var colors = [];
	var name = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		var args = lines[i].split(" ");
		if(args[0] === "NAME") {
			name = lines[i].split(/\s(.+)/)[1];
		}
		else {
			var col = [];
			lines[i].split(",").forEach(function(i) {
				col.push(parseInt(i));
			});
			colors.push(col);
		}
		i++;
	}
	palette[id] = {
		id : id,
		name : name,
		colors : colors
	};
	return i;
}

function parseTile(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store tile source
		drwId = "TIL_" + id;
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 1; // default palette color index is 1
	var isWall = null; // null indicates it can vary from room to room (original version)
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			colorIndex = parseInt( getId(lines[i]) );
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.tile.set( name, id );
		}
		else if (getType(lines[i]) === "WAL") {
			var wallArg = getArg( lines[i], 1 );
			if( wallArg === "true" ) {
				isWall = true;
			}
			else if( wallArg === "false" ) {
				isWall = false;
			}
		}
		i++;
	}

	//tile data
	tile[id] = {
		id : id,
		drw : drwId, //drawing id
		col : colorIndex,
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		name : name,
		isWall : isWall
	};

	return i;
}

function parseSprite(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store sprite source
		drwId = "SPR_" + id;
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 2; //default palette color index is 2
	var dialogId = null;
	var startingInventory = {};
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			colorIndex = parseInt( getId(lines[i]) );
		}
		else if (getType(lines[i]) === "POS") {
			/* STARTING POSITION */
			var posArgs = lines[i].split(" ");
			var roomId = posArgs[1];
			var coordArgs = posArgs[2].split(",");
			spriteStartLocations[id] = {
				room : roomId,
				x : parseInt(coordArgs[0]),
				y : parseInt(coordArgs[1])
			};
		}
		else if(getType(lines[i]) === "DLG") {
			dialogId = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.sprite.set( name, id );
		}
		else if (getType(lines[i]) === "ITM") {
			/* ITEM STARTING INVENTORY */
			var itemId = getId(lines[i]);
			var itemCount = parseFloat( getArg(lines[i], 2) );
			startingInventory[itemId] = itemCount;
		}
		i++;
	}

	//sprite data
	sprite[id] = {
		id : id,
		drw : drwId, //drawing id
		col : colorIndex,
		dlg : dialogId,
		room : null, //default location is "offstage"
		x : -1,
		y : -1,
		walkingPath : [], //tile by tile movement path (isn't saved)
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		inventory : startingInventory,
		name : name
	};
	return i;
}

function parseItem(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store item source
		drwId = "ITM_" + id; // these prefixes are maybe a terrible way to differentiate drawing tyepes :/
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 2; //default palette color index is 2
	var dialogId = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			colorIndex = parseInt( getArg( lines[i], 1 ) );
		}
		// else if (getType(lines[i]) === "POS") {
		// 	/* STARTING POSITION */
		// 	var posArgs = lines[i].split(" ");
		// 	var roomId = posArgs[1];
		// 	var coordArgs = posArgs[2].split(",");
		// 	spriteStartLocations[id] = {
		// 		room : roomId,
		// 		x : parseInt(coordArgs[0]),
		// 		y : parseInt(coordArgs[1])
		// 	};
		// }
		else if(getType(lines[i]) === "DLG") {
			dialogId = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.item.set( name, id );
		}
		i++;
	}

	//item data
	item[id] = {
		id : id,
		drw : drwId, //drawing id
		col : colorIndex,
		dlg : dialogId,
		// room : null, //default location is "offstage"
		// x : -1,
		// y : -1,
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		name : name
	};

	// console.log("ITM " + id);
	// console.log(item[id]);

	return i;
}

function parseDrawing(lines, i) {
	// store drawing source
	var drwId = getId( lines[i] );
	return parseDrawingCore( lines, i, drwId );
}

function parseDrawingCore(lines, i, drwId) {
	var frameList = []; //init list of frames
	frameList.push( [] ); //init first frame
	var frameIndex = 0;
	var y = 0;
	while ( y < tilesize ) {
		var l = lines[i+y];
		var row = [];
		for (x = 0; x < tilesize; x++) {
			row.push( parseInt( l.charAt(x) ) );
		}
		frameList[frameIndex].push( row );
		y++;

		if (y === tilesize) {
			i = i + y;
			if ( lines[i] != undefined && lines[i].charAt(0) === ">" ) {
				// start next frame!
				frameList.push( [] );
				frameIndex++;
				//start the count over again for the next frame
				i++;
				y = 0;
			}
		}
	}

	renderer.SetImageSource(drwId, frameList);

	return i;
}

function parseDialog(lines, i) {
	var id = getId(lines[i]);
	i++;

	// TODO : use this for titles & endings too
	var results = scriptInterpreter.ReadDialogScript(lines,i);
	dialog[id] = results.script;
	i = results.index;

	return i;
}

function parseEnding(lines, i) {
	var id = getId(lines[i]);
	i++;
	var text = lines[i];
	i++;
	ending[id] = text;
	return i;
}

function parseVariable(lines, i) {
	var id = getId(lines[i]);
	i++;
	var value = lines[i];
	i++;
	variable[id] = value;
	return i;
}

function parseFontName(lines, i) {
	fontName = getArg(lines[i], 1);
	i++;
	return i;
}

function parseTextDirection(lines, i) {
	textDirection = getArg(lines[i], 1);
	i++;
	return i;
}

function parseFontData(lines, i) {
	// NOTE : we're not doing the actual parsing here --
	// just grabbing the block of text that represents the font
	// and giving it to the font manager to use later

	var localFontName = getId(lines[i]);
	var localFontData = lines[i];
	i++;

	while (i < lines.length && lines[i] != "") {
		localFontData += "\n" + lines[i];
		i++;
	}

	var localFontFilename = localFontName + fontManager.GetExtension();
	fontManager.AddResource( localFontFilename, localFontData );

	return i;
}

function parseFlag(lines, i) {
	var id = getId(lines[i]);
	var valStr = lines[i].split(" ")[2];
	flags[id] = parseInt( valStr );
	i++;
	return i;
}

function drawTile(img,x,y,context) {
	if (!context) { //optional pass in context; otherwise, use default
		context = ctx;
	}
	context.putImageData(img,x*tilesize*scale,y*tilesize*scale);
}

function drawSprite(img,x,y,context) { //this may differ later (or not haha)
	drawTile(img,x,y,context);
}

function drawItem(img,x,y,context) {
	drawTile(img,x,y,context); //TODO these methods are dumb and repetitive
}

function drawRoom(room,context,frameIndex) { // context & frameIndex are optional
	if (!context) { //optional pass in context; otherwise, use default (ok this is REAL hacky isn't it)
		context = ctx;
	}

	//clear screen
	context.fillStyle = "rgb(" + getPal(curPal())[0][0] + "," + getPal(curPal())[0][1] + "," + getPal(curPal())[0][2] + ")";
	context.fillRect(0,0,canvas.width,canvas.height);

	//draw tiles
	for (i in room.tilemap) {
		for (j in room.tilemap[i]) {
			var id = room.tilemap[i][j];
			if (id != "0") {
				//console.log(id);
				if (tile[id] == null) { // hack-around to avoid corrupting files (not a solution though!)
					id = "0";
					room.tilemap[i][j] = id;
				}
				else {
					// console.log(id);
					drawTile( getTileImage(tile[id],getRoomPal(room.id),frameIndex), j, i, context );
				}
			}
		}
	}

	//draw items
	for (var i = 0; i < room.items.length; i++) {
		var itm = room.items[i];
		drawItem( getItemImage(item[itm.id],getRoomPal(room.id),frameIndex), itm.x, itm.y, context );
	}

	//draw sprites
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === room.id) {
			drawSprite( getSpriteImage(spr,getRoomPal(room.id),frameIndex), spr.x, spr.y, context );
		}
	}
}

// TODO : remove these get*Image methods
function getTileImage(t,palId,frameIndex) {
	return renderer.GetImage(t,palId,frameIndex);
}

function getSpriteImage(s,palId,frameIndex) {
	return renderer.GetImage(s,palId,frameIndex);
}

function getItemImage(itm,palId,frameIndex) {
	return renderer.GetImage(itm,palId,frameIndex);
}

function curPal() {
	return getRoomPal(curRoom);
}

function getRoomPal(roomId) {
	if (room[roomId].pal != null) {
		//a specific palette was chosen
		return room[roomId].pal;
	}
	else {
		if (roomId in palette) {
			//there is a palette matching the name of the room
			return roomId;
		}
		else {
			//use the default palette
			return "0";
		}
	}
	return "0";	
}

var isDialogMode = false;
var isNarrating = false;
var isEnding = false;
var dialogModule = new Dialog();
var dialogRenderer = dialogModule.CreateRenderer();
var dialogBuffer = dialogModule.CreateBuffer();
var fontManager = new FontManager();

function onExitDialog() {
	// var breakShit = null;
	// breakShit();
	console.log("EXIT DIALOG");
	isDialogMode = false;
	if (isNarrating) isNarrating = false;
	if (isDialogPreview) {
		isDialogPreview = false;
		if (onDialogPreviewEnd != null)
			onDialogPreviewEnd();
	}
}

/*
TODO
- titles and endings should also take advantage of the script pre-compilation if possible??
- could there be a namespace collision?
- what about dialog NAMEs vs IDs?
- what about a special script block separate from DLG?
*/
function startNarrating(dialogStr,end) {
	console.log("NARRATE " + dialogStr);

	if(end === undefined) end = false;

	isNarrating = true;
	isEnding = end;
	startDialog(dialogStr);
}

function startItemDialog(itemId) {
	var dialogId = item[itemId].dlg;
	// console.log("START ITEM DIALOG " + dialogId);
	if(dialog[dialogId]){
		var dialogStr = dialog[dialogId];
		startDialog(dialogStr,dialogId);
	}
}

function startSpriteDialog(spriteId) {
	var spr = sprite[spriteId];
	var dialogId = spr.dlg ? spr.dlg : spriteId;
	// console.log("START SPRITE DIALOG " + dialogId);
	if(dialog[dialogId]){
		var dialogStr = dialog[dialogId];
		startDialog(dialogStr,dialogId);
	}
}

function startDialog(dialogStr,scriptId) {
	console.log("START DIALOG ");
	console.log(dialogStr);

	if(dialogStr.length <= 0) {
		console.log("ON EXIT DIALOG -- startDialog 1");
		onExitDialog();
		return;
	}

	isDialogMode = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered( isNarrating /*centered*/ );
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer( dialogBuffer );

	var onScriptEnd = function() {
		if(!dialogBuffer.IsActive()){
			console.log("ON EXIT DIALOG -- startDialog 2");
			onExitDialog();
		}
	};

	if(scriptId === undefined) {
		scriptInterpreter.Interpret( dialogStr, onScriptEnd );		
	}
	else {
		if( !scriptInterpreter.HasScript(scriptId) )
			scriptInterpreter.Compile( scriptId, dialogStr );
		scriptInterpreter.Run( scriptId, onScriptEnd );
	}

}

var isDialogPreview = false;
function startPreviewDialog(script, onScriptEnd) {
	isNarrating = true;

	isDialogMode = true;

	isDialogPreview = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered( true );
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer( dialogBuffer );

	onDialogPreviewEnd = onScriptEnd;

	scriptInterpreter.Eval( script, null );
}

/* NEW SCRIPT STUFF */
var scriptModule = new Script();
var scriptInterpreter = scriptModule.CreateInterpreter();
var scriptUtils = scriptModule.CreateUtils(); // TODO: move to editor.js?
// scriptInterpreter.SetDialogBuffer( dialogBuffer );
</script>

<!-- store default font in separate script tag for back compat-->
<script type="bitsyFontData" id="ascii_small">
FONT ascii_small
SIZE 6 8
CHAR 0
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 1
001110
010001
011011
010001
010101
010001
001110
000000
CHAR 2
001110
011111
010101
011111
010001
011111
001110
000000
CHAR 3
000000
001010
011111
011111
011111
001110
000100
000000
CHAR 4
000000
000000
001010
001110
001110
000100
000000
000000
CHAR 5
000100
001110
001110
000100
011111
011111
000100
000000
CHAR 6
000000
000100
001110
011111
011111
000100
001110
000000
CHAR 7
000000
000000
000000
001100
001100
000000
000000
000000
CHAR 8
111111
111111
111111
110011
110011
111111
111111
111111
CHAR 9
000000
000000
011110
010010
010010
011110
000000
000000
CHAR 10
111111
111111
100001
101101
101101
100001
111111
111111
CHAR 11
000000
000111
000011
001101
010010
010010
001100
000000
CHAR 12
001110
010001
010001
001110
000100
001110
000100
000000
CHAR 13
000100
000110
000101
000100
001100
011100
011000
000000
CHAR 14
000011
001101
001011
001101
001011
011011
011000
000000
CHAR 15
000000
010101
001110
011011
001110
010101
000000
000000
CHAR 16
001000
001100
001110
001111
001110
001100
001000
000000
CHAR 17
000010
000110
001110
011110
001110
000110
000010
000000
CHAR 18
000100
001110
011111
000100
011111
001110
000100
000000
CHAR 19
001010
001010
001010
001010
001010
000000
001010
000000
CHAR 20
001111
010101
010101
001101
000101
000101
000101
000000
CHAR 21
001110
010001
001100
001010
000110
010001
001110
000000
CHAR 22
000000
000000
000000
000000
000000
011110
011110
000000
CHAR 23
000100
001110
011111
000100
011111
001110
000100
001110
CHAR 24
000100
001110
011111
000100
000100
000100
000100
000000
CHAR 25
000100
000100
000100
000100
011111
001110
000100
000000
CHAR 26
000000
000100
000110
011111
000110
000100
000000
000000
CHAR 27
000000
000100
001100
011111
001100
000100
000000
000000
CHAR 28
000000
000000
000000
010000
010000
010000
011111
000000
CHAR 29
000000
001010
001010
011111
001010
001010
000000
000000
CHAR 30
000100
000100
001110
001110
011111
011111
000000
000000
CHAR 31
011111
011111
001110
001110
000100
000100
000000
000000
CHAR 32
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 33
000100
001110
001110
000100
000100
000000
000100
000000
CHAR 34
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 35
000000
001010
011111
001010
001010
011111
001010
000000
CHAR 36
001000
001110
010000
001100
000010
011100
000100
000000
CHAR 37
011001
011001
000010
000100
001000
010011
010011
000000
CHAR 38
001000
010100
010100
001000
010101
010010
001101
000000
CHAR 39
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 40
000100
001000
001000
001000
001000
001000
000100
000000
CHAR 41
001000
000100
000100
000100
000100
000100
001000
000000
CHAR 42
000000
001010
001110
011111
001110
001010
000000
000000
CHAR 43
000000
000100
000100
011111
000100
000100
000000
000000
CHAR 44
000000
000000
000000
000000
000000
001100
001100
001000
CHAR 45
000000
000000
000000
011111
000000
000000
000000
000000
CHAR 46
000000
000000
000000
000000
000000
001100
001100
000000
CHAR 47
000000
000001
000010
000100
001000
010000
000000
000000
CHAR 48
001110
010001
010011
010101
011001
010001
001110
000000
CHAR 49
000100
001100
000100
000100
000100
000100
001110
000000
CHAR 50
001110
010001
000001
000110
001000
010000
011111
000000
CHAR 51
001110
010001
000001
001110
000001
010001
001110
000000
CHAR 52
000010
000110
001010
010010
011111
000010
000010
000000
CHAR 53
011111
010000
010000
011110
000001
010001
001110
000000
CHAR 54
000110
001000
010000
011110
010001
010001
001110
000000
CHAR 55
011111
000001
000010
000100
001000
001000
001000
000000
CHAR 56
001110
010001
010001
001110
010001
010001
001110
000000
CHAR 57
001110
010001
010001
001111
000001
000010
001100
000000
CHAR 58
000000
000000
001100
001100
000000
001100
001100
000000
CHAR 59
000000
000000
001100
001100
000000
001100
001100
001000
CHAR 60
000010
000100
001000
010000
001000
000100
000010
000000
CHAR 61
000000
000000
011111
000000
000000
011111
000000
000000
CHAR 62
001000
000100
000010
000001
000010
000100
001000
000000
CHAR 63
001110
010001
000001
000110
000100
000000
000100
000000
CHAR 64
001110
010001
010111
010101
010111
010000
001110
000000
CHAR 65
001110
010001
010001
010001
011111
010001
010001
000000
CHAR 66
011110
010001
010001
011110
010001
010001
011110
000000
CHAR 67
001110
010001
010000
010000
010000
010001
001110
000000
CHAR 68
011110
010001
010001
010001
010001
010001
011110
000000
CHAR 69
011111
010000
010000
011110
010000
010000
011111
000000
CHAR 70
011111
010000
010000
011110
010000
010000
010000
000000
CHAR 71
001110
010001
010000
010111
010001
010001
001111
000000
CHAR 72
010001
010001
010001
011111
010001
010001
010001
000000
CHAR 73
001110
000100
000100
000100
000100
000100
001110
000000
CHAR 74
000001
000001
000001
000001
010001
010001
001110
000000
CHAR 75
010001
010010
010100
011000
010100
010010
010001
000000
CHAR 76
010000
010000
010000
010000
010000
010000
011111
000000
CHAR 77
010001
011011
010101
010001
010001
010001
010001
000000
CHAR 78
010001
011001
010101
010011
010001
010001
010001
000000
CHAR 79
001110
010001
010001
010001
010001
010001
001110
000000
CHAR 80
011110
010001
010001
011110
010000
010000
010000
000000
CHAR 81
001110
010001
010001
010001
010101
010010
001101
000000
CHAR 82
011110
010001
010001
011110
010010
010001
010001
000000
CHAR 83
001110
010001
010000
001110
000001
010001
001110
000000
CHAR 84
011111
000100
000100
000100
000100
000100
000100
000000
CHAR 85
010001
010001
010001
010001
010001
010001
001110
000000
CHAR 86
010001
010001
010001
010001
010001
001010
000100
000000
CHAR 87
010001
010001
010101
010101
010101
010101
001010
000000
CHAR 88
010001
010001
001010
000100
001010
010001
010001
000000
CHAR 89
010001
010001
010001
001010
000100
000100
000100
000000
CHAR 90
011110
000010
000100
001000
010000
010000
011110
000000
CHAR 91
001110
001000
001000
001000
001000
001000
001110
000000
CHAR 92
000000
010000
001000
000100
000010
000001
000000
000000
CHAR 93
001110
000010
000010
000010
000010
000010
001110
000000
CHAR 94
000100
001010
010001
000000
000000
000000
000000
000000
CHAR 95
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 96
001100
001100
000100
000000
000000
000000
000000
000000
CHAR 97
000000
000000
001110
000001
001111
010001
001111
000000
CHAR 98
010000
010000
011110
010001
010001
010001
011110
000000
CHAR 99
000000
000000
001110
010001
010000
010001
001110
000000
CHAR 100
000001
000001
001111
010001
010001
010001
001111
000000
CHAR 101
000000
000000
001110
010001
011110
010000
001110
000000
CHAR 102
000110
001000
001000
011110
001000
001000
001000
000000
CHAR 103
000000
000000
001111
010001
010001
001111
000001
001110
CHAR 104
010000
010000
011100
010010
010010
010010
010010
000000
CHAR 105
000100
000000
000100
000100
000100
000100
000110
000000
CHAR 106
000010
000000
000110
000010
000010
000010
010010
001100
CHAR 107
010000
010000
010010
010100
011000
010100
010010
000000
CHAR 108
000100
000100
000100
000100
000100
000100
000110
000000
CHAR 109
000000
000000
011010
010101
010101
010001
010001
000000
CHAR 110
000000
000000
011100
010010
010010
010010
010010
000000
CHAR 111
000000
000000
001110
010001
010001
010001
001110
000000
CHAR 112
000000
000000
011110
010001
010001
010001
011110
010000
CHAR 113
000000
000000
001111
010001
010001
010001
001111
000001
CHAR 114
000000
000000
010110
001001
001000
001000
011100
000000
CHAR 115
000000
000000
001110
010000
001110
000001
001110
000000
CHAR 116
000000
001000
011110
001000
001000
001010
000100
000000
CHAR 117
000000
000000
010010
010010
010010
010110
001010
000000
CHAR 118
000000
000000
010001
010001
010001
001010
000100
000000
CHAR 119
000000
000000
010001
010001
010101
011111
001010
000000
CHAR 120
000000
000000
010010
010010
001100
010010
010010
000000
CHAR 121
000000
000000
010010
010010
010010
001110
000100
011000
CHAR 122
000000
000000
011110
000010
001100
010000
011110
000000
CHAR 123
000110
001000
001000
011000
001000
001000
000110
000000
CHAR 124
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 125
001100
000010
000010
000011
000010
000010
001100
000000
CHAR 126
001010
010100
000000
000000
000000
000000
000000
000000
CHAR 127
000100
001110
011011
010001
010001
011111
000000
000000
CHAR 128
001110
010001
010000
010000
010001
001110
000100
001100
CHAR 129
010010
000000
010010
010010
010010
010110
001010
000000
CHAR 130
000011
000000
001110
010001
011110
010000
001110
000000
CHAR 131
001110
000000
001110
000001
001111
010001
001111
000000
CHAR 132
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 133
001100
000000
001110
000001
001111
010001
001111
000000
CHAR 134
001110
001010
001110
000001
001111
010001
001111
000000
CHAR 135
000000
001110
010001
010000
010001
001110
000100
001100
CHAR 136
001110
000000
001110
010001
011110
010000
001110
000000
CHAR 137
001010
000000
001110
010001
011110
010000
001110
000000
CHAR 138
001100
000000
001110
010001
011110
010000
001110
000000
CHAR 139
001010
000000
000100
000100
000100
000100
000110
000000
CHAR 140
000100
001010
000000
000100
000100
000100
000110
000000
CHAR 141
001000
000000
000100
000100
000100
000100
000110
000000
CHAR 142
001010
000000
000100
001010
010001
011111
010001
000000
CHAR 143
001110
001010
001110
011011
010001
011111
010001
000000
CHAR 144
000011
000000
011111
010000
011110
010000
011111
000000
CHAR 145
000000
000000
011110
000101
011111
010100
001111
000000
CHAR 146
001111
010100
010100
011111
010100
010100
010111
000000
CHAR 147
001110
000000
001100
010010
010010
010010
001100
000000
CHAR 148
001010
000000
001100
010010
010010
010010
001100
000000
CHAR 149
011000
000000
001100
010010
010010
010010
001100
000000
CHAR 150
001110
000000
010010
010010
010010
010110
001010
000000
CHAR 151
011000
000000
010010
010010
010010
010110
001010
000000
CHAR 152
001010
000000
010010
010010
010010
001110
000100
011000
CHAR 153
010010
001100
010010
010010
010010
010010
001100
000000
CHAR 154
001010
000000
010010
010010
010010
010010
001100
000000
CHAR 155
000000
000100
001110
010000
010000
001110
000100
000000
CHAR 156
000110
001001
001000
011110
001000
001001
010111
000000
CHAR 157
010001
001010
000100
011111
000100
011111
000100
000000
CHAR 158
011000
010100
010100
011010
010111
010010
010010
000000
CHAR 159
000010
000101
000100
001110
000100
000100
010100
001000
CHAR 160
000110
000000
001110
000001
001111
010001
001111
000000
CHAR 161
000110
000000
000100
000100
000100
000100
000110
000000
CHAR 162
000110
000000
001100
010010
010010
010010
001100
000000
CHAR 163
000110
000000
010010
010010
010010
010110
001010
000000
CHAR 164
001010
010100
000000
011100
010010
010010
010010
000000
CHAR 165
001010
010100
000000
010010
011010
010110
010010
000000
CHAR 166
001110
000001
001111
010001
001111
000000
001111
000000
CHAR 167
001100
010010
010010
010010
001100
000000
011110
000000
CHAR 168
000100
000000
000100
001100
010000
010001
001110
000000
CHAR 169
000000
000000
011111
010000
010000
010000
000000
000000
CHAR 170
000000
000000
111111
000001
000001
000000
000000
000000
CHAR 171
010000
010010
010100
001110
010001
000010
000111
000000
CHAR 172
010000
010010
010100
001011
010101
000111
000001
000000
CHAR 173
000100
000000
000100
000100
001110
001110
000100
000000
CHAR 174
000000
000000
001001
010010
001001
000000
000000
000000
CHAR 175
000000
000000
010010
001001
010010
000000
000000
000000
CHAR 176
010101
000000
101010
000000
010101
000000
101010
000000
CHAR 177
010101
101010
010101
101010
010101
101010
010101
101010
CHAR 178
101010
111111
010101
111111
101010
111111
010101
111111
CHAR 179
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 180
000100
000100
000100
111100
000100
000100
000100
000100
CHAR 181
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 182
010100
010100
010100
110100
010100
010100
010100
010100
CHAR 183
000000
000000
000000
111100
010100
010100
010100
010100
CHAR 184
000000
111100
000100
111100
000100
000100
000100
000100
CHAR 185
010100
110100
000100
110100
010100
010100
010100
010100
CHAR 186
010100
010100
010100
010100
010100
010100
010100
010100
CHAR 187
000000
111100
000100
110100
010100
010100
010100
010100
CHAR 188
010100
110100
000100
111100
000000
000000
000000
000000
CHAR 189
010100
010100
010100
111100
000000
000000
000000
000000
CHAR 190
000100
111100
000100
111100
000000
000000
000000
000000
CHAR 191
000000
000000
000000
111100
000100
000100
000100
000100
CHAR 192
000100
000100
000100
000111
000000
000000
000000
000000
CHAR 193
000100
000100
000100
111111
000000
000000
000000
000000
CHAR 194
000000
000000
000000
111111
000100
000100
000100
000100
CHAR 195
000100
000100
000100
000111
000100
000100
000100
000100
CHAR 196
000000
000000
000000
111111
000000
000000
000000
000000
CHAR 197
000100
000100
000100
111111
000100
000100
000100
000100
CHAR 198
000100
000111
000100
000111
000100
000100
000100
000100
CHAR 199
010100
010100
010100
010111
010100
010100
010100
010100
CHAR 200
010100
010111
010000
011111
000000
000000
000000
000000
CHAR 201
000000
011111
010000
010111
010100
010100
010100
010100
CHAR 202
010100
110111
000000
111111
000000
000000
000000
000000
CHAR 203
000000
111111
000000
110111
010100
010100
010100
010100
CHAR 204
010100
010111
010000
010111
010100
010100
010100
010100
CHAR 205
000000
111111
000000
111111
000000
000000
000000
000000
CHAR 206
010100
110111
000000
110111
010100
010100
010100
010100
CHAR 207
000100
111111
000000
111111
000000
000000
000000
000000
CHAR 208
010100
010100
010100
111111
000000
000000
000000
000000
CHAR 209
000000
111111
000000
111111
000100
000100
000100
000100
CHAR 210
000000
000000
000000
111111
010100
010100
010100
010100
CHAR 211
010100
010100
010100
011111
000000
000000
000000
000000
CHAR 212
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 213
000000
000000
000000
000000
000000
000000
111111
111111
CHAR 214
000000
000000
000000
000000
000000
111111
111111
111111
CHAR 215
000000
000000
000000
000000
111111
111111
111111
111111
CHAR 216
000000
000000
000000
111111
111111
111111
111111
111111
CHAR 217
000000
000000
111111
111111
111111
111111
111111
111111
CHAR 218
000000
111111
111111
111111
111111
111111
111111
111111
CHAR 219
111111
111111
111111
111111
111111
111111
111111
111111
CHAR 220
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 221
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 222
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 223
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 224
111110
111110
111110
111110
111110
111110
111110
111110
CHAR 225
000000
011100
010010
011100
010010
010010
011100
010000
CHAR 226
011110
010010
010000
010000
010000
010000
010000
000000
CHAR 227
000000
011111
001010
001010
001010
001010
001010
000000
CHAR 228
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 229
000000
000000
001111
010010
010010
001100
000000
000000
CHAR 230
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 231
000000
000000
001010
010100
000100
000100
000100
000000
CHAR 232
001110
000100
001110
010001
001110
000100
001110
000000
CHAR 233
001100
010010
010010
011110
010010
010010
001100
000000
CHAR 234
000000
001110
010001
010001
001010
001010
011011
000000
CHAR 235
001100
010000
001000
000100
001110
010010
001100
000000
CHAR 236
000000
000000
001010
010101
010101
001010
000000
000000
CHAR 237
000000
000100
001110
010101
010101
001110
000100
000000
CHAR 238
000000
001110
010000
011110
010000
001110
000000
000000
CHAR 239
000000
001100
010010
010010
010010
010010
000000
000000
CHAR 240
000000
011110
000000
011110
000000
011110
000000
000000
CHAR 241
000000
000100
001110
000100
000000
001110
000000
000000
CHAR 242
010000
001100
000010
001100
010000
000000
011110
000000
CHAR 243
000000
000000
111111
111000
100110
100001
100000
111111
CHAR 244
000000
000000
111111
000111
011001
100001
000001
111111
CHAR 245
000100
000100
000100
000100
000100
010100
001000
000000
CHAR 246
001010
000000
001110
010001
010001
010001
001110
000000
CHAR 247
111110
111110
111110
111110
111110
111110
111110
111110
CHAR 248
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 249
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 250
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 251
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 252
001010
000000
010010
010010
010010
010110
001010
000000
CHAR 253
011000
000100
001000
011100
000000
000000
000000
000000
CHAR 254
000000
000000
000000
011110
110010
110011
111110
001111
CHAR 255
010010
111111
010010
010010
111111
010010
000000
000000
</script>

</head>


<!-- DOCUMENT BODY -->
<body onload='startExportedGame()'>
	<!-- GAME CANVAS -->
    <canvas id='game'></canvas>
<script src="BitsyNav3.js"></script>
</body>


</html>
